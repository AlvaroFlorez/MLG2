--- 
title: "Notas de clase: Modelo lineal general II"
author: "Alvaro J. Flórez"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
        bookdown::pdf_document2
bibliography: [ModeloLineal.bib]
biblio-style: apalike
link-citations: yes

header-includes:
  - \newcommand{\bepsilon}{\boldsymbol \epsilon}
  - \newcommand{\bpsi}{\boldsymbol \psi}
  - \newcommand{\bmu}{\boldsymbol \mu}
  - \newcommand{\cl}{ℓ}
  - \newcommand{\bx}{\boldsymbol x}
  - \newcommand{\bX}{\boldsymbol X}
  - \newcommand{\bZERO}{\boldsymbol 0}
  - \newcommand{\bONE}{\boldsymbol 1}
  - \newcommand{\tr}{\mbox{tr}}
  - \newcommand{\bb}{\boldsymbol b}
  - \newcommand{\hatbb}{\widehat{\bb}}
  - \newcommand{\hatb}{\widehat{b}}
  - \newcommand{\bc}{\boldsymbol c}
  - \newcommand{\bC}{\boldsymbol C}
  - \newcommand{\bD}{\boldsymbol D}
  - \newcommand{\be}{\boldsymbol e}
  - \newcommand{\bH}{\boldsymbol H}
  - \newcommand{\bI}{\boldsymbol I}
  - \newcommand{\bl}{\boldsymbol l}
  - \newcommand{\bL}{\boldsymbol L}
  - \newcommand{\bM}{\boldsymbol M}
  - \newcommand{\bp}{\boldsymbol p}
  - \newcommand{\bP}{\boldsymbol P}
  - \newcommand{\br}{\boldsymbol r}
  - \newcommand{\bR}{\boldsymbol R}
  - \newcommand{\bt}{\boldsymbol t}
  - \newcommand{\bT}{\boldsymbol T}
  - \newcommand{\bu}{\boldsymbol u}
  - \newcommand{\bU}{\boldsymbol U}
  - \newcommand{\by}{\boldsymbol y}
  - \newcommand{\bY}{\boldsymbol Y}
  - \newcommand{\bZ}{\boldsymbol Z}
  - \newcommand{\bV}{\boldsymbol V}
  - \newcommand{\bW}{\boldsymbol W}
  - \newcommand{\bz}{\boldsymbol z}
  - \newcommand{\tildey}{\widetilde{y}}
  - \newcommand{\tildeby}{\widetilde{\by}}
  - \newcommand{\tildetheta}{\widetilde{\theta}}
  - \newcommand{\tildemu}{\widetilde{\mu}}
  
  - \newcommand{\haty}{\widehat{y}}
  - \newcommand{\hatby}{\widehat{\by}}
  
  - \newcommand{\hatalpha}{\widehat{\alpha}}
  - \newcommand{\balpha}{\boldsymbol \alpha}
  - \newcommand{\hatbalpha}{\widehat{\balpha}}
    
  - \newcommand{\bbeta}{\boldsymbol \beta}
  - \newcommand{\hatbeta}{\widehat{\beta}}
  - \newcommand{\hatbbeta}{\widehat{\bbeta}}
  - \newcommand{\bgamma}{\boldsymbol \gamma}
  - \newcommand{\hatmu}{\widehat{\mu}}
  - \newcommand{\hatsigma}{\widehat{\sigma}}
  - \newcommand{\hatlambda}{\widehat{\lambda}}
  - \newcommand{\hatbLambda}{\widehat{\bLambda}}
  - \newcommand{\btheta}{\boldsymbol \theta}
  - \newcommand{\bLambda}{\boldsymbol \Lambda}
  - \newcommand{\bvarepsi}{\boldsymbol \varepsilon}
  - \newcommand{\bpi}{\boldsymbol \pi}
  
  - \newcommand{\Sres}{SS_{\mbox{res}}}
  - \newcommand{\Sreg}{SS_{\mbox{reg}}}
  - \newcommand{\Stotal}{SS_{\mbox{T}}}

  - \newcommand{\MSres}{MS_{\mbox{res}}}
  - \newcommand{\MSreg}{MS_{\mbox{reg}}}
  
  - \renewcommand{\figurename}{Figura}
  - \renewcommand{\tablename}{Tabla}
---

# Introducción {-}
Estas son las notas de clase del curso Modelo Lineal General II. Los temas que se tratan son:

1. Variables indicadoras.
2. Modelos polinomiales.
3. Multicolinealidad.
4. Selección de variables.
5. Introducción a modelos no lineales.
6. Introducción al modelo lineal generalizado (modelo logístico - modelo Poisson).
7. Introducción al modelo lineal mixto

Tenga en cuenta que el propósito de estas notas de clase no es reemplazar los textos guías. Para el estudio más detallado de los temas revisados, se recomiendan las siguientes lecturas:

- *Introduction to Linear Regression Analysis*, Fifth Ed., 2012, by Montgomery, D. C., Peck, E. A. and Vining, G. G. **(Texto guía)**
- *Applied Regression Analysis*, Third Ed., 1998, by Draper, N. R. and Smith, H., Wiley.
- *Theory and Applications of the Linear Models*, 2000, by Graybill, F. A., Duxbury.
- *Applied Linear Statistical Models*, Fifth Ed., 2005, by Kutner, M. H, Nachtsheim, C. J., Neter, J. and Li, W., McGraw-Hill.
- *Análisis de Regresión. Introducción Teórica y Práctica basada en R*, 2011, by F. Tusell.
- *Applied Linear Regression*, Fourth Ed.,  2014, by S. Weisberg.
- *Applied Regression Analysis \& Generalized Linear Models*, 2016, by J. Fox.

<!--chapter:end:index.Rmd-->

# Variables indicadoras (o dummies)
```{r preamble1, include=FALSE}
library(MASS)
library(alr4)
data(ais,package='alr4')
data(UN11)
n= nrow(UN11)
Names = rownames(UN11)
mod.UN11 = lm(log(fertility)~log(ppgdp)+pctUrban,data=UN11)
p=3
res.UN11 = studres(mod.UN11)
Order.res = order(abs(res.UN11),decreasing = T)
```

## Ejemplos

### Datos de atletas australianos
Los datos `ais` de la libreria `alr4` tiene información sobre 202 atletas de élite de Australia (102 hombres y 100 mujeres). Se quiere evaluar la relación entre la concentración de hemoglobina (``Hg``, g/dl) y el índice de masa corporal (``BMI``, kg/m$^2$).

```{r AtletesFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de atletas. Densidad de la hemoglobina para hombres y mujeres (derecha) y diagrama de dispersión entre la homoglobina y el índice de masa corporal (izquierda). Negro para hombres y rojo para mujeres.",warning=FALSE,message = FALSE}
data(ais)
par(mfrow=c(1,2))
plot(density(ais$Hg[ais$Sex==0]),xlim=c(11,20),lwd=2,main = '',ylab='Densidad',xlab='Hg (g/dl)')
lines(density(ais$Hg[ais$Sex==1]),col=2,lwd=2)
plot(Hg~BMI,data=ais,col=ais$Sex+1,ylab='Hg (g/dl)',xlab='BMI')
```
En la Figura \@ref(fig:AtletesFigure) (izquierda) vemos que los niveles de hemoglobina son mayores para hombres que para mujeres. En la Figura \@ref(fig:AtletesFigure) (derecha) observamos que hay una relación positiva entre la hemoglobina y el índice de masa corporal tanto para hombres como para mujeres. Esto nos puede indicar que ingresar el sexo del atleta en el modelo puede mejorarnos el ajuste.

### Datos de la ONU
Retomemos los datos de la ONU (`UN11` de la librería `alr4`). Las variables de interés son:

- **fertility**: Número esperado de nacidos vivos por mujer.
- **ppgdp**: producto nacional bruto per cápita (PNB, en dólares).
- **Purban**: el porcentaje de la población que vive en un área urbana.
- **lifeExpF**: esperanza de vida femenina (años).
- **group**: si el país pertenece a la OCDE (Organización para la Cooperación y el Desarrollo Económicos), África o otros.

Por ahora consideremos la relación entre la fertilidad y el PNB per cápita, teniendo en cuenta el grupo al que pertenece cada país.
```{r UN11Figure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de la ONU. Relación entre la fertilidad y el PNB per cápita para los países de OCDE (puntos negros), países africanos (puntos verdes) y los otros países (rojos)",warning=FALSE,message = FALSE}
data(UN11)
plot(log(fertility)~log(ppgdp),data=UN11,col=UN11$group,xlab='log PNB per cápita (dólares)', ylab='log # esperado de nacidos vivos por mujer')
```
En la Figura \@ref(fig:UN11Figure) podemos observar que, en general, cuando el PNB aumenta, la tasa de fertilidad disminuye. Sin embargo, esta relación puede variar según la categoría del país. Para los países de la OCDE, esta relación no es fuerte. Mientras que para los demás se mantiene esta relación negativa. Por esta razón sería de gran importancia incluir esta variable categórica dentro del modelo.

## Variables indicadoras
Las covariables categóricas entran en un modelo como variables indicadoras (o también llamadas *dummies*). En el caso que la covariable $(X)$ tenga dos categorías, entonces se crea una variable indicadora. Por ejemplo, para los datos de los atletas, el sexo requiere una indicadora:
\[
u_{i} = \begin{cases}
1 & \mbox{ si la observación i es hombre}, \\
0 & \mbox{ si la observación i es mujer}. \\
\end{cases}
\]
Aquí mujer es llamada la categoría de referencia.

En caso que la covariable categórica tenga $k$ categorías, se tienen que crear $k-1$ variables indicadoras. Por ejemplo, para la variable grupo de país en los datos de la ONU se requieren 2 variables indicadoras $(u_{j})$ como lo muestra la Tabla \@ref(tab:dosIndica).

```{r dosIndica, echo=F, results='asis'}
tb1 = data.frame(
  cat = c('OECD','otro','África'),
  u1 = c(0,1,0),u2=c(0,0,1))
colnames(tb1) = c('Categoría','$u_{1}$', '$u_{2}$')
knitr::kable(tb1, escape = FALSE,caption ='Variables indicadoras para la variable ``group`` de los datos de la ONU', booktabs = TRUE)
```

### Modelos con covariables categóricas
Suponga que se quiere ajustar un modelo para una variable respuesta $Y$ en función de dos covariables: una continua $X$ y una indicadora $Z$ (es decir una variable categórica con dos 2 categorías). El modelo propuesto es el siguiente:
\begin{equation}
y_{i}  = \beta_{0} + x_{i}\beta_{1} + z_{i}\beta_{2} + x_{i}z_{i}\beta_{3} + \varepsilon_{i},
(\#eq:modInter)
\end{equation}
donde $\varepsilon_{i} \sim N(0,\sigma^{2})$.

Tenemos que, si $z_i=0$:
\[
E(Y | X=x_i, Z=0) = \beta_{0} + x_{i}\beta_{1}.
\]
Mientras que, si $z_i=1$:
\[
E(Y | X=x_i, Z=1) = (\beta_{0}+\beta_{2}) + x_{i}(\beta_{1}+\beta_{3}).
\]
Por lo que el modelo \@ref(eq:modInter) genera dos rectas, una para cada categoría. $\beta_2$ indica la diferencia de intercepto entre las dos categorías y $\beta_3$ la diferencia entre pendientes. En la Figura \@ref(fig:Rectas1)(izquierda) se observan las dos rectas que se obtienen a partir de este modelo. Si se elimina la interacción entre variables, se obtienen dos rectas paralelas (Figura \@ref(fig:Rectas1), derecha).


```{r Rectas1,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Efecto de la interacción entre variable continua e indicadora. Modelo general (izquierda) y modelo de líneas paralelas (derecha)."}
par(mfrow=c(1,2))
plot(NULL,NULL,ylim=c(0,1),xlim=c(0,1),xlab='covariable = X',ylab = 'variable respuesta = Y')
abline(a=0.9,b=-0.7,lwd=2)
abline(a=0.8,b=-0.4,lwd=2,col=2)
text(0.3,0.8,pos=4,bquote(E(Y)~'='~beta[0]~'+'~beta[1]~X[1]),cex=0.8,col=1)
text(0.4,0.7,pos=4,bquote(E(Y)~'='~beta[0]~'+'~beta[2]~'+'~'('~beta[1]~'+'~beta[3]~')'~X[1]),cex=0.8,col=2)
plot(NULL,NULL,ylim=c(0,1),xlim=c(0,1),xlab='covariable = X',ylab = 'variable respuesta = Y')
abline(a=0.9,b=-0.7,lwd=2)
abline(a=0.7,b=-0.7,lwd=2,col=2)
text(0.3,0.8,pos=4,bquote(E(Y)~'='~beta[0]~'+'~beta[1]~X[1]),cex=0.8,col=1)
text(0.4,0.7,pos=4,bquote(E(Y)~'='~beta[0]~'+'~beta[2]~'+'~beta[1]~X[1]),cex=0.8,col=2)
```

### Modelo para los datos de atletas australianos
Para los datos de los atletas, se sugiere el siguiente modelo:
\begin{equation}
\begin{split}
\mbox{Hg}_{i} =& \beta_{0} + \mbox{Sex}_{i}\beta_{1} + \mbox{BMI}_{i}\beta_{2} + \mbox{Sex}_{i}\mbox{BMI}_{i}\beta_{3} + \varepsilon_{i},
\end{split}
\nonumber
\end{equation}
donde:
\[
\mbox{Sex}_{i} = \begin{cases}
1 & \mbox{ si la observación i corresponde a una mujer}, \\
0 & \mbox{ de otra forma}. \\
\end{cases}
\]
Note que en la base de datos ``ais``, la variable ``sex`` ya está codificada de esta forma. Si la variable no está codificada de forma numérica, ``R`` eligirá la categoría de referencia de forma automática. 

Para ajustar el modelo utilizamos la función ``lm`` (``Sex*BMI`` aquí estamos incluyendo los efectos de ``BMI`` y ``Sex``, así como la interacción):
```{r MCOatletas}
mod.ais = lm(Hg~Sex*BMI, data=ais)
summary(mod.ais)
```
Aquí tenemos que $\widehat{\beta}_{2} =`r round(mod.ais$coeff[3],2)`$, lo que nos indica que el valor esperado del nivel de hemoglobina aumenta en $`r round(mod.ais$coeff[3],2)`$ g/dl por cada aumento unitario en el índice de masa corporal de los hombres. Para las mujeres, el efecto del índice de masa corporal sobre el nivel de hemoglobina también es positivo, pero con una pendiente menor $\widehat{\beta}_{2} +\widehat{\beta}_{3} = `r round(mod.ais$coeff[2],2)` - `r abs(round(mod.ais$coeff[3],2))` = `r round(mod.ais$coeff[2]+mod.ais$coeff[3],2)`$. 

La representación gráfica del modelo se puede observar en la Figura \@ref(fig:AtletesAjuste). Aquí vemos que la pendiente para las mujeres es un poco menor que para los hombres.

```{r AtletesAjuste, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de atletas. Ajuste del modelo para la homoglobina en función  del índice de masa corporal y sexo. Línea negra para hombres y línea roja para mujeres.",warning=FALSE,message = FALSE}
plot(Hg~BMI,data=ais,col=ais$Sex+1,ylab='Hg (g/dl)',xlab='BMI')
abline(a=mod.ais$coefficients[1],b=mod.ais$coefficients[3],lwd=2)
abline(a=mod.ais$coefficients[1]+mod.ais$coefficients[2],b=mod.ais$coefficients[3]+mod.ais$coefficients[4],col=2,lwd=2)
```
Si miramos la significancia del $\widehat{\beta}_3$ (valor-$p$ igual a 0.276), podemos concluir que las diferencias en pendiente no son significativas. Por lo que, el efecto del índice de masa corporal sobre los niveles de hemoglobina es el mismo para mujeres que para hombres.

Si queremos evaluar si hay diferencias entre hombres y mujeres, debemos evaluar la siguiente hipótesis:
\[
H_{0}: \beta_{1} = \beta_3 = 0.
\]
En ``R``, esto lo podemos realizar usando la función ``anova()`` (prueba F) comparando el modelo completo contra el modelo reducido (sin la variable ``Sex``):
```{r ANOVAatletas}
mod.ais.red = lm(Hg~BMI, data=ais)
anova(mod.ais.red,mod.ais)
```
Aquí vemos que se rechaza $H_0$ por lo que hay diferencias en la relación de la homoglobina y el índice de masa corporal entre hombres y mujeres ($\beta_1$ o $\beta_3$ es diferente de cero, pero no ambos).

El modelo con lineas paralelas es:
\[
\mbox{Hg}_{i} = \beta_{0} + \mbox{Sex}_{i}\beta_{1} + \mbox{BMI}_{i}\beta_{2} +  \varepsilon_{i},
\]
donde $\varepsilon_{i} \sim N(0, \sigma^{2})$, y se calcula de la siguiente forma:
```{r MCO2atletas}
mod.ais.lp = lm(Hg~Sex+BMI, data=ais)
summary(mod.ais.lp)
```
La estimación del efecto asociado al sexo indica la diferencia media del nivel de hemoglobina entre hombres y mujeres. En la Figura \@ref(fig:AtletesAjuste2) vemos que el modelo de líneas paralelas tiene casi el mismo ajuste que el modelo general.

```{r AtletesAjuste2, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de atletas. Ajuste del modelo general (línea solida) y el modelo líneas paralelas (línea discontinua) para la homoglobina en función  del índice de masa corporal y sexo. Líneas negra para hombres y líneas roja para mujeres.",warning=FALSE,message = FALSE}
plot(Hg~BMI,data=ais,col=ais$Sex+1,ylab='Hg (g/dl)',xlab='BMI')
abline(a=mod.ais$coefficients[1],b=mod.ais$coefficients[3],lwd=2)
abline(a=mod.ais$coefficients[1]+mod.ais$coefficients[2],b=mod.ais$coefficients[3]+mod.ais$coefficients[4],col=2,lwd=2)
abline(a=mod.ais.lp$coefficients[1],b=mod.ais.lp$coefficients[3],lwd=2,lty=2)
abline(a=mod.ais.lp$coefficients[1]+mod.ais.lp$coefficients[2],b=mod.ais.lp$coefficients[3],col=2,lwd=2,lty=2)
```
### Modelo para los datos de la ONU
El modelo propuesto es el siguiente:
\begin{equation}
\begin{split}
\log\mbox{fertility}_{i} =& \beta_{0} + \mbox{u}_{1i}\beta_{1}+\mbox{u}_{2i}\beta_{2} + \log\mbox{ppgdp}_{i}\beta_{3} + \\ & \mbox{u}_{1i}\log\mbox{ppgdp}_{i}\beta_{4} + \mbox{u}_{2i}\log\mbox{ppgdp}_{i}\beta_{5} + \varepsilon_{i},
\end{split}
\nonumber
\end{equation}
donde:
\[
\mbox{u}_{1i} = \begin{cases}
1 & \mbox{ si el país i pertenece a la categoría otro}, \\
0 & \mbox{ de otra forma}, \\
\end{cases} \quad \mbox{ y } \quad 
\mbox{u}_{2i} = \begin{cases}
1 & \mbox{ si el país i pertenece a África}, \\
0 & \mbox{ de otra forma}. \\
\end{cases}
\]
Por lo tanto, OECD es la categoría de referencia.

El modelo ajustado es:
```{r MCOUN11}
mod.UN11 = lm(log(fertility)~group*log(ppgdp), data=UN11)
summary(mod.UN11)
```
```{r MCOUN11res,echo=F,include=FALSE}
Beta.UN11 = round(mod.UN11$coefficients,3)
```
A partir de estos resultados obtenemos tres rectas que describen el valor esperado del logarítmo de la fertilidad en función del logarítmo del PNB per cápita, una para cada tipo de país. Para los países de la OCDE, tenemos que:
\[
E(\log\mbox{fertility}) = `r Beta.UN11[1]` + `r Beta.UN11[4]`\log \mbox{ppgdp}.
\]
Para los países Africanos:
\[
E(\log\mbox{fertility}) = `r Beta.UN11[1]+Beta.UN11[3]`  `r Beta.UN11[4]+Beta.UN11[6]`\log \mbox{ppgdp}.
\]
Finalmente, para los otros países:
\[
E(\log\mbox{fertility}) = `r Beta.UN11[1]+Beta.UN11[2]`  `r Beta.UN11[4]+Beta.UN11[5]`\log \mbox{ppgdp}.
\]
Aquí vemos que para los países que no son de la OCDE, el producto nacional bruto tiene un efecto significativo negativo sobre la tasa de fertilidad. Mientras que para los países de la OCDE, este efecto es positivo, aunque no es significativo. Esto mismo lo podemos ver gráficamente en la Figura \@ref(fig:MCOUN11Figure).
```{r MCOUN11Figure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de la ONU. Ajuste del modelo para la fertilidad en función  del PNB y tipo de país. Países de OCDE (línea negra), países africanos (línea verde) y los otros países (línea roja)",warning=FALSE,message = FALSE}
Beta.UN11 = mod.UN11$coefficients
plot(log(fertility)~log(ppgdp),data=UN11,col=UN11$group,xlab='log PNB per cápita (dólares)', ylab='log # esperado de nacidos vivos por mujer')
abline(a=Beta.UN11[1],b=Beta.UN11[4],lwd=2)
abline(a=Beta.UN11[1]+Beta.UN11[2],b=Beta.UN11[4]+Beta.UN11[5],col=2,lwd=2)
abline(a=Beta.UN11[1]+Beta.UN11[3],b=Beta.UN11[4]+Beta.UN11[6],col=3,lwd=2)
```
Usando la función ``relevel()`` se puede cambiar la categoría de referencia. Por ejemplo, si queremos que la categoría de referencia sea ``other``:
```{r MCOUN112, eval = FALSE}
UN11.alt = UN11
UN11.alt$group =  relevel(UN11.alt$group,ref ='other')
mod.UN11.alt = lm(log(fertility)~group*log(ppgdp), data=UN11.alt)
summary(mod.UN11.alt)
```
Cambiar la categoría de referencia no cambia en nada los resultados del ajuste. Solo cambian la interpretación de los coeficientes.

Se podría hacer la siguiente pregunta, ¿el efecto del PNB sobre la fertilidad es el mismo para cada tipo de país?. Para resolver esta pregunta, se plantea la siguiente hipótesis:
\[
H_0: \beta_4 = \beta_5 = 0.
\]
Usando la función ``anova()`` (prueba F) en R:
```{r MCOUN11ANOVA}
mod.UN11.red = lm(log(fertility)~group+log(ppgdp), data=UN11)
anova(mod.UN11.red,mod.UN11)
```
Este resultado indica que hay evidencia suficiente para concluir que el efecto del PNB sobre la fertilidad no es el mismo para cada tipo de país.

Ahora, podríamos preguntarnos: ¿las pendientes son las mismas para las categorías de otro y África?. Para esto, se plantea la siguiente hipótesis:
\[
H_0: \beta_4 = \beta_5.
\]
También se puede expresar de la siguiente forma:
\[
H_{0}: \bL\bbeta = \begin{pmatrix}
0 & 0 & 0 & 0 & 1 & -1
\end{pmatrix} \begin{pmatrix}
\beta_0 \\ \beta_1 \\ \beta_2 \\ \beta_3 \\ \beta_4 \\ \beta_5
\end{pmatrix} = 0
\]
Esto, en R es:
```{r MCOUN11ANOVA2}
L = matrix(c(0,0,0,0,1,-1),1,6,byrow = T)
linearHypothesis(mod.UN11, hypothesis.matrix=L)
```
Dado que no se rechaza $H_0$, el efecto del PNB sobre la fertilidad es el mismo para los países Africano y los de la categoría de otros.

En resumen, a partir del análisis de regresión:
- El efecto del PNB per cápita es diferente cada tipo de país.
- Para los países miembros de la OECD, el efecto es positivo (aunque no es significativo).
- Para los países de áfrica y otros, el efecto es negativo (y no es significativamente diferente).

<!--chapter:end:01-Indicadoras.Rmd-->

# Modelos polinomiales
```{r preamble2, include=FALSE}
library(MASS)
library(alr4)
library(pBrackets)

polfun = function(x,coef){
  p = 0:length(coef)
  y = mapply(function(z){
    x^p[z]*coef[z]
  },z=1:length(coef))
  colSums(t(y))
}

linearfun <- function (x, y) {
  return (x+y)
}

Interfun <- function (x, y) {
  return (x+y+0.5*x*y)
}

quadfun <- function (x, y) {
  return (x+y-0.5*x^2 - 0.5*y^2)
}


data(cakes)
data(Boston)
```

## Ejemplos

### Pasteles
Con los datos `cakes` de la libreria `alr4` se tienen dos objetivos. Primero, evaluar el efecto de la temperatura y tiempo de horneado sobre la palatabilidad de mazclas de pasteles para hornear. Segundo, encontrar la combinación de estos factores que maximizan la palatabilidad.

Como variable respuesta (`Y`) se tiene el promedio de calificación de la palatabilidad de cuatro pasteles horneados. Mientras que las covariables son: el tiempo de horneado (`X1`, en minutos) y la temperatura (`X2`, en grados Fahrenheit)

```{r CakesFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de pasteles. Diagrama de dispersión.",warning=FALSE,message = FALSE}
library(alr4)
data(cakes)
plot(cakes[,-1])
```


### Datos de Boston
La base de datos `Boston` de la libreria `MASS` contiene información sobre 506 suburbios del area metropolitana de Boston. El objetivo del estudio es evaluar la relación del precio de las viviendas y la concentración de contaminación ambienta. En esta sección evaluaremos la relación entre la concentración anual de óxido de nitrógeno ($y$, en partes por diez millones) y la distancia a cinco centros de empleo.

```{r BostonFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de Boston. Relación entre el óxido de nitrógeno y la distancia a centros de empleo.",warning=FALSE,message = FALSE}
library(MASS)
data(Boston)
plot(nox~dis,data=Boston,ylab='NOx',xlab='distancia a centros de empleo')
```

## Modelos polinomiales
El modelo:
$$
y_{i} = \beta_{0} + \beta_{1}x_{i} + \varepsilon_i,
$$

describe la relación lineal entre $y$ y $x_1$. Si las relación entre las variables presentan curvaturas, se puede considerar un modelo polinómico de la forma:
$$
y_{i} = \beta_{0} + \beta_{1}x_{i} + \beta_{2}x_{i}^{2} + \ldots + + \beta_{k}x_{i}^{k} + \varepsilon_i.
$$
Este modelo se sigue considerando como un modelo lineal, dado que es lineal en los parámetros $\bbeta$. En la Figura \@ref(fig:Polinomios)  se puede observar diferentes curvas para modelos lineales (orden 1), cuadráticos (orden 2) y cúbicos (orden 3). Aquí vemos que este tipo de modelos son muy versatiles. Caulquier función suave se puede ajustar meidante un polinomio de grado suficientemente alto. Por esta razón, los modelos polinomicos son usados en casos donde las relaciones entre las variables son no-lineales y se pueden aproximar por un polinomio.


```{r Polinomios,echo=FALSE, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Polinomio de grado 1 (linea negra), grado 2 (linea roja) y grado 3 (linea verde)."}

x= seq(-1,1,length.out = 100)
y1 = polfun(x,c(0,1))
y2 = polfun(x,c(0.8,0,-1.5))
y3 = polfun(x,c(0,-1.6,0,2.6))


plot(x,y1,type='l',lwd=2,ylab='y',xlab='x')
lines(x,y2,col=2,lwd=2)
lines(x,y3,col=3,lwd=2)
```


En el caso que se tengan dos covariables, un modelo de orden 2 se expresa de la forma:
$$
y_{i} = \beta_{0} + \beta_{1}x_{1i} + \beta_{2}x_{2i} + \beta_{3}x_{1i}^2 + \beta_{4}x_{2i}^2 + \beta_{5}x_{1i}x_{2i} + \varepsilon_i.
$$
En las Figuras \@ref(fig:modPoli1)-\@ref(fig:modPoli3) muestran el valor esperado de $Y$ en un modelo lineal (asumiendo $\beta_3=\beta_4=\beta_5=0$), cuadrático y con interacción (asumiendo $\beta_3=\beta_4=0$).

```{r modPoli1,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Valor esperado de $Y$ en un modelo lineal (izquierda) y gráfico de contorno (derecha)."}
par(mfrow=c(1,2))
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, linearfun)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue",
      xlab='covariable 1',ylab='covariable 2',zlab='respuesta')
contour(x, y, z,xlab='covariable 1',ylab='covariable 2')
```

El número de parámetros incrementa rápidamente con el número de covariables. Con $k$ covariables, tenemos: un intercepto, $k$ términos lineales, $k$
términos cuadráticos, y $k(k - 1)/2$ interacciones. Por esta razón, en muchos casos, no se toman en cuentas las interacción cuando el número de covariables es grande.

```{r modPoli2,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Valor esperado de $Y$ en un modelo cuadrático (izquierda) y gráfico de contorno (derecha)."}
par(mfrow=c(1,2))
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, quadfun)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
contour(x, y, z)
```


```{r modPoli3,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Valor esperado de $Y$ en un modelo lineal con interacción (izquierda) y gráfico de contorno (derecha)."}
par(mfrow=c(1,2))
x <- seq(-10, 10, length= 30)
y <- x
z <- outer(x, y, Interfun)
persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")
contour(x, y, z)
```

Hay aspectos que se deben tener en la práctica cuando se implementa un modelo polinomial: 

- **Selección del orden:** La idea es mantener el orden del polinomio bajo. Si embargo, si es muy bajo no logra capturar la curvatura presente en los datos. En caso que el orden sea grande, el modelo es innecesariamente más complejo y puede haber problemas de multicolinealidad.

Si los datos exige un modelo de orden alto $(k > 3)$, se pueden hacer transformación sobre las variables, y así, poder ajustar un modelo polinomial de orden bajo (por ejemplo cuadrático).


La selección del orden puede hacerse de dos formas. (1) ** Hacia delante**: empezar con un modelo de orden $1$ e incrementar el orden uno a uno hasta que un término mayor ya no sea significativo. **Hacia atrás:** empezar con el modelo más complejo y eliminar los términos mayores uno a uno hasta que todos sean significativos.

- **Extrapolación**: La extrapolación con modelos polinomiales puede ser muy peligrosa. Por ejemplo en la Figura \@ref(fig:extrapolacion) podemos ajustar un modelo de orden dos a los datos (linea negra). Si hacemos una predicción fuera del rango de los datos, el valor esperado predicho sigue el comportamiento cuadrático propuesto. Sin embargo, el valor esperado de $Y$ puede seguir un comportamiento diferente (linea roja discontinua). Lo que lleva a tener una predicción sesgada. 

```{r extrapolacion,echo=FALSE, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Problema de extrapolación."}
x= seq(0,9,length.out=100)
y = 2 + 2*x - 0.25*x^2

plot(x,y,type='l',ylim=c(0,8),xaxt='n',yaxt='n',lwd=2,xlab='covariable',ylab='respuesta')
y1 = 2 + 2*x[x<4] - 0.25*x[x<4]^2  + rnorm(n=sum(x<4),0,0.5)
points(x[x<4],y1)

b0 = 6-0.1*4
yv = c(y[x<4],b0+0.1*x[x>=4])
lines(x,yv,lty=2,col=2,lwd=2)

abline(v=4,lty=1)
abline(v=0,lty=1)
axis(1,2,c('región de los datos'))
axis(1,6,c('extrapolación'))

x0 = 7.5
y11 = b0+0.1*x0
y21 = 2 + 2*x0 - 0.25*x0^2
points(x0,y11,pch=19,col=2,lwd=2)
points(x0,y21,pch=19,lwd=2)
axis(1,x0,expression(x[0]))
brackets(x0+0.1, y11, x0+0.1, y21,h=0.2,ticks=0.5,type=1,xpd=F)
text(x0+0.2,mean(c(y11,y21)),'sesgo',pos =4)
```

- **Multicolinealidad**:  Al aumentar el polinomio, la matriz $\bX'\bX$ se vuelve mal acondicionada. Es decir, las estimaciones pueden ser inestables y los errores estándar se inflan. Este problema se puede solucionar centrando las covariables. Por ejemplo en un modelo de orden 2:
$$
E(Y | X=x) = \beta_{0} + \beta_{1}(x-\bar{x}) + \beta_{2}(x-\bar{x})^{2}.
$$
Otra solución es usando polinomios ortogonales.

### Interpretación de los coeficientes
Considere un modelo de orden 2. El valor esperado de $Y$ está dado por:
\[
E(Y| X_{1}=x_1,X_{2}=x_2) = \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2} + \beta_{3}x_{1}^{2} + \beta_{4}x_{2}^{2} + \beta_{5}x_{1}x_{2}.
\]
Si $x_{1}$ cambia en $\delta$ unidades $(x_{1} + \delta)$, tenemos que:
$$
E(Y| X_{1}=x_1+\delta,X_{2}=x_2) =  \beta_{0} + \beta_{1}(x_{1}+\delta) + \beta_{2}x_{2} + \beta_{3}(x_{1} + \delta)^{2} + \beta_{4}x_{2}^{2} + \beta_{5}(x_{1}+\delta)x_{2}.
$$
Ahora calculando la diferencia:
$$
E(Y| X_{1}=x_1+\delta,X_{2}=x_2) - E(Y| X_{1}=x_1,X_{2}=x_2) = (\beta_{1}\delta + \beta_{3}\delta^{2}) + 2\beta_{3}\delta x_{1} + \beta_{5}\delta x_{2}.
$$
Aquí podemos observar que el efecto del cambio $\delta$ en $X_1$ depende de ambas covariables y del valor de $\delta$. Por esta razón es complicado interpretar coeficientes en modelos polinomiales.


### Pasteles
Para los datos de los pasteles, se propone el siguiente modelo:
$$
y_{i} = \beta_{0} + \beta_{1}x_{1i} + \beta_{2}x_{2i} + \beta_{3}x_{1i}^2 + \beta_{4}x_{2i}^{2} + \beta_{5}x_{1i}x_{2i} + \varepsilon_{i}.
$$
El ajuste del modelo es:
```{r CakesFit, echo=T, warning=FALSE,message = FALSE}
mod.cakes = lm(Y ~ X1*X2 + I(X1^2)+I(X2^2),data=cakes)
summary(mod.cakes)
```
Además, los factores de inflación de varianza son los siguientes:
```{r CakesFit2, echo=T, warning=FALSE,message = FALSE}
car::vif(mod.cakes)
```
Aquí vemos que los VIF presentan valores muy altos, producto de ajustar un modelo cuadrático. Ahora consideremos el modelo con las covariables centradas:
```{r CakesFit3, echo=T, warning=FALSE,message = FALSE}
cakes$X1c = cakes$X1 - mean(cakes$X1)
cakes$X2c = cakes$X2 - mean(cakes$X2)
modc.cakes = lm(Y ~ X1c*X2c + I(X1c^2)+I(X2c^2),data=cakes)
summary(modc.cakes)
```
Los VIFs del modelo con las covariables centradas son:
```{r CakesFit4, echo=T, warning=FALSE,message = FALSE}
car::vif(modc.cakes)
```
En este caso, los VIF decrecieron considerablemente con respecto al modelo con las covariables originales.

En la figura \@ref(fig:predCakes) podemos observar el valor esperado estimado de la palatabilidad para diferentes valores de tiempo y temperatura de horneado.

```{r PredCakes,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Datos de pasteles. Valor esperado de la palatabilidad para diferentes valores de tiempo y temperatura de horneado. "}
par(mfrow=c(1,2))
X01.1 = data.frame(X1c = seq(32,38,length.out = 100)-mean(cakes$X1),
                   X2c = 360 - mean(cakes$X2))
X01.2 = data.frame(X1c = seq(32,38,length.out = 100)-mean(cakes$X1),
                   X2c = 350 - mean(cakes$X2))
predX1.1 = predict(modc.cakes,X01.1)
predX1.2 = predict(modc.cakes,X01.2)

X02.1 = data.frame(X1c = 33-mean(cakes$X1),
                   X2c = seq(330,365,length.out = 100) - mean(cakes$X2))
X02.2 = data.frame(X1c = 35-mean(cakes$X1),
                   X2c = seq(330,365,length.out = 100) - mean(cakes$X2))
predX2.1 = predict(modc.cakes,X02.1)
predX2.2 = predict(modc.cakes,X02.2)


plot(X01.1$X1c+mean(cakes$X1),predX1.2,type='l',lwd=2,ylab='palatabilidad',
     xlab='tiempo de horneado (minutos)')
lines(X01.2$X1c+mean(cakes$X1),predX1.1,col=2,lwd=2)
legend('bottomright',c('X2=350','X2=360'),col=1:2,lty=1)
plot(X02.1$X2c+mean(cakes$X2),predX2.2,type='l',lwd=2,ylab='palatabilidad',
     xlab='temperatura de horneado (Fahrenheit)')
lines(X02.2$X2c+mean(cakes$X2),predX2.1,col=2,lwd=2)
legend('bottomright',c('X1=35','X1=33'),col=1:2,lty=1)
```

En la Figura \@ref(fig:predCakes) (izquierda) vemos que, cuando la temperatura es de 350 grados Fahrenheit, el máximo de palatabilidad que se obtiene en un tiempo entre 36 y 37 minutos. Sin embargo, cuando la temperatura se incrementa a 360, la máxima palatibilidad que se puede lograr es menor. Además, se obtiene en un tiempo también menor. El efecto de la interacción también se puede observar en la Figura \@ref(fig:predCakes2) (derecha), pero ahora fijando el tiempo de horneado y variando la temperatura. El gráfico de contornos (Figura \@ref(fig:predCakes2)) muestra que la máxima palatabilidad se observa cuando la temperatura está alrededor de 355 y el tiempo de horneado está entre 35 y 36 minutos.

```{r predCakes2,echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de pasteles. Gráfica de contornos."}
X1 = seq(32, 38, length.out = 50)
X2 = seq(335, 365, length= 50)

y <- outer(X= X1, Y = X2, FUN = function(x, y) {
    predict(modc.cakes, newdata = data.frame(X1c = x-mean(cakes$X1), X2c = y-mean(cakes$X2)))
})

contour(X1, X2, y,xlab='tiempo de horneado (minutos)',
        ylab='temperatura de horneado (Fahrenheit)')
```

```{r CakesMax, echo=FALSE,warning=FALSE,message = FALSE}
MaxY = optim(c(35,350),function(x){
  x1 = x[1] - mean(cakes$X1)
  x2 = x[2] - mean(cakes$X2)
  sum(modc.cakes$coefficients*c(1,x1,x2,x1^2,x2^2,x1*x2))
},control=list(fnscale=-1))
maxY = round(MaxY$value,1)
maxX1 = round(MaxY$par[1],1)
maxX2 = round(MaxY$par[2],1)

IC95 = round(predict(modc.cakes,data.frame(X1c=maxX1 - mean(cakes$X1),
                              X2c=maxX2 - mean(cakes$X2)),interval = 'confidence'),1)

```

Para determinar en que combinación de tiempo (X1) y temperatura de horneado (X2) se obtiene la máxima palatabilidad. Por lo tanto, debemos resolver la siguiente ecuación:
\[
\frac{\partial E(Y)}{\partial \bx}  = \frac{\partial}{\partial \bx} \left( \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2} + \beta_{3}x_{1}^2 + \beta_{4}x_{2}^{2} + \beta_{5}x_{1}x_{2} \right) = \bZERO,
\]
verificando que se obtiene un máximo.

Resolviendo la ecuación anterior, el máximo valor esperado de palatabilidad $(`r maxY`)$ se obtiene en un tiempo de horneado de `r maxX1` minutos y a una temperatura de \ang{`r maxX2`}F. El intervalo del 95\% de confianza en este punto es: $(`r IC95[2]`, `r IC95[3]`)$.


### Datos de Boston
```{r BostonFit0, echo=F, warning=FALSE,message = FALSE}
Boston$disc = Boston$dis - mean(Boston$dis)
mod1.Boston = lm(I(nox^-1.5)~disc,data=Boston)
mod2.Boston = lm(I(nox^-1.5)~disc+I(disc^2),data=Boston)
mod3.Boston = lm(I(nox^-1.5)~disc+I(disc^2)+I(disc^3),data=Boston)


R2.3 = round(summary(mod3.Boston)$r.squared,3)
R2.2 = round(summary(mod2.Boston)$r.squared,3)
```
Para los datos de contaminación se puede proponer el siguiente modelo:
\[
\mbox{NOx}_{i}^{-1.5} = \beta_{0} + \beta_{1}\mbox{dis}_{i} + \beta_{2}\mbox{dis}_{i}^{2} + \beta_{3}\mbox{dis}_{i}^{3} + \varepsilon_{i}.
\]
La potencia en la variable respuesta se seleccionó usando el método de Box-Cox. El ajuste del modelo es el siguiente:
```{r BostonFit, echo=T, warning=FALSE,message = FALSE}
Boston$disc = Boston$dis - mean(Boston$dis)
mod3.Boston = lm(I(nox)^{-1}~disc+I(disc^2)+I(disc^3),data=Boston)
summary(mod3.Boston)
```
En la Figura \@ref{figPredBoston} muestra el ajuste del modelo cúbico. Para hacer comparaciones, se muestra también el ajuste lineal y cuadrático. Se observa que el modelo cúbico presenta un buen ajuste. El modelo explica alrededor del $`r R2.3*100`$\% de la variabilidad de la concentración anual de óxido de nitrógeno. Con el modelo cuadrático, el coeficiente de determinación es de $`r R2.2`$. Sin embargo, se puede observar que este ajuste es un poco deficiente cuando las distancias son muy grandes (mayores a 11).

```{r figPredBoston,echo=FALSE, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de Boston. Valor esperado de la concentración anual de óxido de nitrógeno (en partes por diez millones) en función de las distancias a cinco centros de empleo (media ponderada). Modelo lineal (negro), cuadrático (rojo) y cúbico (verde)."}
x = seq(1,13,length.out=100)

pred1 = predict(mod1.Boston,list(disc=x-mean(Boston$dis)))
pred2 = predict(mod2.Boston,list(disc=x-mean(Boston$dis)))
pred3 = predict(mod3.Boston,list(disc=x-mean(Boston$dis)))

plot(nox~dis,data=Boston,ylab='NOx',xlab='distancia a centros de empleo')
lines(x,pred1,lwd=2)
lines(x,pred2,col=2,lwd=2)
lines(x,pred3,col=3,lwd=2)
```

## Regresión por segmentos
El modelo por segmentos se puede expresar como:
$$
y_{i} = \beta_{0} + \beta_{1}x_{i} + \beta_{2}(x_{i}-t)^{0}_{+} +  \beta_{3}(x_{i}-t)^{1}_{+} + \varepsilon_{i}.
$$
donde:
$$
(x_{i}-t)_{+}^{r}  = \begin{cases}
0 & \mbox{ si } x_{i} + t \leq 0, \\
(x_{i}-t)^{r} & \mbox{ si } x_{i} + t > 0. \\
\end{cases}
\nonumber
$$
Por lo tanto, si $x_{i} \leq t$, $E(y_{i}| x_{i}) = \beta_{0} + \beta_{1}x_{i}$. Mientras que, si $x_{i} > t$, tenemos que $E(y_{i}| x_{i}) = (\beta_{0} + \beta_{2} - \beta_{1}t) + (\beta_{1} + \beta_{3})x_{i}$. 

Este modelo esta representado graficamente en la Figura \@ref(RegSegmentos). Cuando $\beta_2 \neq 0$, el modelo presenta una discontinuidad en $t$. Mientras que, cuando $\beta_2 = 0$, el modelo presenta un cambio de pendiente en el punto $t$. Además, $\beta_3$ indica el cambio de pendiente. 

```{r RegSegmentos,echo=FALSE, fig.height = 4, fig.width = 9,fig.align = "center",fig.cap = "Modelo de regresión por segmentos. Modelo con discontinuidad en $t$ (izquierda). Modelo con cambio de pendiente en $t$ (derecha)."}
par(mfrow=c(1,2))
b0 = 0.1
b1 = 0.5
b2 = 0.1
b3 = 0.3

x0 = c(0,0.5)
y0 = b0+b1*x0

x1 = c(0.5,1)
y1 = b0-b3*0.5+b2+(b1+b3)*x1
plot(NULL,NULL,xlim=c(-0.08,1),ylim=c(0,1),ylab = 'respuesta',
     xlab='covariable')
lines(x0,y0,lwd=2)
lines(x1,y1,lwd=2)
abline(v=0.5,lty=2)
brackets(0.5, y0[2], 0.5, y1[1],h=0.05,ticks=0.5,type=1,xpd=T)
text(0.5-0.08,mean(c(y0[2],y1[1])),expression(beta[2]))

brackets(0, 0, 0, b0,h=0.05,ticks=0.5,type=1,xpd=T)
text(0-0.08,b0/2,expression(beta[0]))


x00 = c(0.1,0.25)
y00 = y0 = b0+b1*x00
lines(x00,c(y00[1],y00[1]))
lines(c(x00[2],x00[2]),y00)
text(x00[2],mean(y00),expression(beta[1]),pos=4)
x11 = c(0.65,0.65+0.15)
y11 = b0-b3*0.5+b2+(b1+b3)*x11
lines(x11,c(y11[1],y11[1]))
lines(c(x11[2],x11[2]),y11)
text(x11[2],mean(y11),expression(beta[1]+beta[3]),pos=4)


b0 = 0.1
b1 = 0.5
b2 = 0
b3 = 0.3

x0 = c(0,0.5)
y0 = b0+b1*x0

x1 = c(0.5,1)
y1 = b0-b3*0.5+b2+(b1+b3)*x1
plot(NULL,NULL,xlim=c(-0.08,1),ylim=c(0,1),ylab = 'respuesta',
     xlab='covariable')
lines(x0,y0,lwd=2)
lines(x1,y1,lwd=2)
abline(v=0.5,lty=2)

brackets(0, 0, 0, b0,h=0.05,ticks=0.5,type=1,xpd=T)
text(0-0.08,b0/2,expression(beta[0]))


x00 = c(0.1,0.25)
y00 = y0 = b0+b1*x00
lines(x00,c(y00[1],y00[1]))
lines(c(x00[2],x00[2]),y00)
text(x00[2],mean(y00),expression(beta[1]),pos=4)
x11 = c(0.65,0.65+0.15)
y11 = b0-b3*0.5+b2+(b1+b3)*x11
lines(x11,c(y11[1],y11[1]))
lines(c(x11[2],x11[2]),y11)
text(x11[2],mean(y11),expression(beta[1]+beta[3]),pos=4)
```
Aquí asumimos que $t$ es conocido. Si este valor se asume como desconocido, debe estimarse a partir de los datos como un parámetro adicional. Sin embargo, se tendría que recurrir a un método estimación para modelos no-lineales.

### Ejemplo

```{r LotesFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de costos por lote. Diagram de dispersión de el costo de producción promedio por unidad (USD) y el tamaño del lote (unidades).",warning=FALSE,message = FALSE}
library(MPV)
data(p7.11)
plot(p7.11,ylab='costo de producción por unidad (USD)',xlab='Unidades por lote')
```
Considere la base de datos `p7.11` de la librería `MPV`. Aquí se quiere modelar la relación entre el costo de producción promedio por unidad (USD) y el tamaño del lote (unidades). Este relación se puede observar en la Figura \@ref(fig:LotesFigure). Se puede observar que la relación entre las variables es lineal. Sin embargo, se aprecia un posible cambio de pendiente en el punto $x=200$. Por esta razón se propone el siguiente modelo:
$$
y_{i} = \beta_{0} + \beta_{1}x_{i} + \beta_{2}(x_{i}-200)_{+}^{1} + \varepsilon_{i}.
$$
Note que no se asume ninguna discontinuidad. El ajuste del modelo es:

```{r LotesFit, echo=T,warning=FALSE,message = FALSE}
p7.11$x2 = p7.11$x - 200
p7.11$x2[p7.11$x < 200] = 0
mod.lotes = lm(y~.,data=p7.11)
summary(mod.lotes)
```
A partir del ajuste podemos concluir que, por cada unidad que incrementa el lote, el costo de producción disminuye en $0.05$USD. Si embargo, si el tamaño del lote es mayor a $200$, el costo de producción disminuye solamente $0.01$USD cuando el lote aumenta en un artículo. Gráficamente, el ajuste se puede observar en la Figura \@ref(fig:LotesFigure2).

```{r LotesFigure2, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de costos por lote. Diagram de dispersión de el costo de producción promedio por unidad (USD) y el tamaño del lote (unidades).",warning=FALSE,message = FALSE}
b.lotes = mod.lotes$coefficients
plot(p7.11$x,p7.11$y,ylab='costo de producción por unidad (USD)',xlab='unidades por lote')
x = c(100,200)
lines(x,b.lotes[1]+x*b.lotes[2],lwd=2)
x = c(200,300)
lines(x,b.lotes[1]-200*b.lotes[3]+x*(b.lotes[2]+b.lotes[3]),lwd=2)
abline(v=200,lty=2)
```

<!--chapter:end:02-ModelosPolinomiales.Rmd-->

# Multicolinealidad
```{r preamble3, include=FALSE}
library(MASS)
library(alr4)
library(isdals)

data(cement,package = 'MPV')
mod.cement = lm(y ~ x1+x2+x3+x4,data=cement)
s.mod.cement = summary(mod.cement)

data(bodyfat)
```

## Ejemplos

### Cemento
Los datos `data(cement)` en la librería `MASS` corresponden a un experimento sobre calor emanado en el fraguado de diferentes combinaciones químicas de cemento. Se tiene una muestra de $13$ fraguados de cemento Portlan. En cada muestra, se midió con precisión los porcentajes de los cuatro ingredientes químicos principales (covariables). Mientras el cemento fraguaba, también se midió la cantidad de calor desprendido (cals/gm, variable respuesta).


Los cuatro ingredientes químicos son:

- **`x1`** aluminato tricálcico (\%).
- **`x2`** silicato tricálcico (\%).
- **`x3`** tetra-aluminio ferrita de calcio (\%).
- **`x4`** silicato dicálcico (\%). 

En la Figura \@ref(fig:CementFigure) podemos observar que hay relaciones lineales positivas entre la variable respuesta, y las covariables aluminato tricálcico y silicato tricálcico. Mientras que la relación con la variable silicato dicálcico es negativa. También podemos notar que hay una relación negativa fuerte en las covariables aluminato tricálcico y tetra-aluminio ferrita de calcio, y entre silicato tricálcico y silicato dicálcico.

```{r CementFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de cemento. Diagrama de dispersión.",warning=FALSE,message = FALSE}
data(cement,package = 'MASS')
plot(cement[,c(5,1:4)])
```
Para estos datos, se propone el siguiente modelo:
\[
y_{i} = \beta_{0} + x_{1i}\beta_{1} + x_{2i}\beta_{2} + x_{3i}\beta_{3} + x_{4i}\beta_{4} + \varepsilon_{i}.
\]
Los resultados del ajuste son:
```{r CementFit, echo=T, warning=FALSE,message = FALSE}
mod.cement = lm(y ~ x1+x2+x3+x4,data=cement)
summary(mod.cement)
```
Note que el ajuste es bueno, el $`r round(s.mod.cement$r.squared*100,1)`$\% de la variabilidad de la cantidad de calor desprendido durante la fraguado es explicada por el modelo. Sin embargo, los resultados de las pruebas de hipótesis individuales sobre los coeficientes muestran que no son significantes. 

### Grasa corporal
Se tiene una muestra de $20$ mujeres saludables con edades entre $25$ y $34$ años (`data(bodyfat)`  en la librería `isdals`). La medición del porcentaje de grasa corporal es caro y engorroso, por lo tanto se quiere buscar un modelo que proporcione predicciones fiables. Como variables de este modelo se utiliza:

- **`Triceps`:** pliegue cutáneo del tríceps (cm).
- **`Thigh`:** circunferencia del muslo (cm).
- **`Midarm`:** circunferencia del brazo medio (cm).

La Figura \@(fig:bodyfatFigure) muestra la relación entre variables. Podemos observar que hay una relación fuerte del \% de masa corporal con las covariables Triceps y Thigh. Además hay también una relación lineal fuerte entre esas dos covariables.

```{r bodyfatFigure, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de grasa corporal. Diagrama de dispersión.",warning=FALSE,message = FALSE}
library(isdals)
data(bodyfat)
plot(bodyfat)
```
El modelo propuesto es:
\[
\mbox{Fat}_{i} = \beta_{0} + \mbox{Triceps}_{i}\beta_{1} + \mbox{Thigh}_{i}\beta_{2} + \mbox{Midarm}_{i}\beta_{3} + \varepsilon_{i}.
\]
El ajuste del modelo es el siguiente:
```{r BodyfatFit, echo=T, warning=FALSE,message = FALSE}
mod.bodyfat = lm(Fat ~ Triceps+Thigh+Midarm,data=bodyfat)
summary(mod.bodyfat)
```
Asi como en el caso anterior, observamos que el modelo explica gran parte de la variabilidad del \% de grasa corporal. Sin embargo, los valores $p$ de las pruebas individuales sobre los coeficientes son altos.

## Multicolinealidad
El estimador de $\bbeta$ es $\hatbbeta = (\bX'\bX)^{-1}\bX'\by$. Además, $V(\hatbbeta) = \sigma^{2}(\bX'\bX)^{-1}$. Por lo tanto requiere que $\bX$ sea de rango completo. Es decir, que hayan columnas que sean linealmente dependientes. En algunos casos, las columnas de $\bX$ son casi linealmente dependientes o colineales,lo que lleva a que $\bX'\bX$ se casi singular, lo que provoca problemas a la hora de hacer inferencias. 

Sea $\bx_j$ la $j$-ésima columna de la matriz $\bX$, por lo tanto $\bX = (\bONE,\bx_{1},\ldots,\bx_{p-1})$. Los vectores $\bx_{1},\bx_{2},\ldots,\bx_{p-1}$ son linealmente dependientes si hay conjunto de constantes $a_{1},a_{2},\ldots, a_{p-1}$ no todas igual a cero, tal que:
\[
\sum_{j=1}^{p-1}a_{j}\bx_{j} = c, \mbox{ donde }c\mbox{ es una constante.}
\]
Si esto se cumple para un subconjunto de $\bX$, el rango de la matriz $\bX'\bX$ es menor que $p$, y por lo tanto, $(\bX'\bX)^{-1}$ no existe.

Si la relación es aproximada $(\sum_{j=1}^{p-1}a_{j}\bx_{j} \approx c)$, existe el problema de multicolinealidad.

Vamos a ilustrar el efecto de la multicolinealidad con un ejemplo sencillo considerando un modelo lineal con dos covariables:
$$
\by^{*} = \bZ\bbeta + \bvarepsi,
$$
donde $\bZ$ es la matriz de covariables escaladas con longitud unitaria. Esto es:
$$
y_{i}^{*} = \frac{y_{i}-\bar{y}}{\sqrt{SST}}, \mbox{ y } z_{ij} = \frac{x_{ij} - \bar{x}_{j}}{\sqrt{s_{jj}}},
$$
donde $s_{jj} = \sum_{i=1}^{n}(x_{ij}-\bar{x}_{j})^{2}$. De esta forma $\bZ'\bZ$ es la matriz de correlación de las covariables, 
$$
\bZ'\bZ = \begin{pmatrix}
1 & r_{12} \\ r_{12} & 1
\end{pmatrix},
$$
y $\bZ'\by$ es el vector de correlaciones entre $y$ y las dos covariables:
$$
\bZ'\by^{*} = \begin{pmatrix}
r_{y1} \\ r_{y2}
\end{pmatrix}.
$$
Por lo que el estimador por MCO de $\bb$ es:
$$
\hatbb = \begin{pmatrix}
1 & r_{12} \\ r_{12} & 1
\end{pmatrix}^{-1}\begin{pmatrix}
r_{y1} \\ r_{y2}
\end{pmatrix} = \begin{pmatrix}
\frac{1}{1-r_{12}^{2}} & \frac{-r_{12}}{1-r_{12}^{2}} \\ \frac{-r_{12}}{1-r_{12}^{2}} & \frac{1}{1-r_{12}^{2}} \end{pmatrix} \begin{pmatrix}
r_{1y} \\ r_{2y}
\end{pmatrix}.
$$
Particularmente, tenemos:
$$
\hatb_{1} = \frac{r_{1y}-r_{12}r_{2y}}{1-r_{12}^{2}} \mbox{ y } \hatb_{2} = \frac{r_{2y}-r_{12}r_{1y}}{1-r_{12}^{2}}.
$$
Además, la matriz de varianzas-covarianzas de $\hatbb$ es:
\begin{equation}
V(\hatbb) = \sigma^{2} \begin{pmatrix}
\frac{1}{1-r_{12}^{2}} & \frac{-r_{12}}{1-r_{12}^{2}} \\ \frac{-r_{12}}{1-r_{12}^{2}} & \frac{1}{1-r_{12}^{2}} \end{pmatrix}.
(\#eq:varbb)
\end{equation}
En \@ref(eq:varbb) podemos observar que la varianza de los coeficientes $\hatbb$ tienden a infinito cuando $|r_{12}|\rightarrow 1$. Mientras que se hace mínima cuando las covariables están incorrelacionadas $(r_{12}=0)$. Es decir, una fuerte correlación entre $x_1$ y $x_2$ da como resultado grandes varianzas y covarianzas para $\hatbb$. 

Por esta razón es preferible tener covariables que sean ortogonales. Puesto que así se garantiza la menor varianza para $\hatbbeta$. Sin embargo, las covariables son díficiles de controlar en estudios observacionales. 

Ahora consideremos un modelo con $p-1$ covariables,
$$
y_{i}^{*} = b_{1}z_{i1} + b_{2}z_{i2} + \ldots + b_{p-1}z_{i,p-1} + \varepsilon_{i}.
$$
Las ecuaciones normales son:
$$
\begin{pmatrix}
1 & r_{12} & r_{13} & \ldots & r_{1,p-1}  \\ r_{12} & 1 & r_{23} & \ldots & r_{2,p-1} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
r_{1,p-1} & r_{2,p-1} & r_{3,p-1} & \ldots & 1
\end{pmatrix} \begin{pmatrix}
b_{1} \\ b_{2} \\ \vdots \\ b_{p-1}
\end{pmatrix} = \begin{pmatrix}
r_{y1} \\ r_{y2} \\ \vdots \\ r_{y,p-1}
\end{pmatrix}.
$$
Por lo que el estimador de $\bb$ es: 
$$
\hatbb = \bR^{-1}\bZ'\by^{*}, \mbox{donde }\bR = \bZ'\bZ.
$$
Se puede demostrar que los elementos de la diagonal de la matriz $\bR^{-1}$ son:
$$
\{\bR^{-1}\}_{jj} = \frac{1}{1-R^{2}_{j}}, j=1,\ldots,p-1,
$$
donde $R^{2}_{j}$ es el coeficiente de determinación de la regresión de $z_{j}$ en función de las $(p-2)$ covariables restantes. Es decir, coeficiente de determinacón del siguiente ajuste:
$$
z_{ij} = z_{i1}\alpha_1 + z_{i2}\alpha_2 + \ldots + z_{i,j-1}\alpha_{j-1} + z_{i,j+1}\alpha_{j+1} + \ldots + z_{i,p-1}\alpha_{p-1} + \varepsilon_i.
$$

Por lo que la varianza del estimador de $\bb$ es: 
$$
V(\hatb_{j}) = \frac{\sigma^{2}}{1-R^{2}_{j}}.
$$
Por lo que, si $z_j$ se puede expresar como una combinación lineal aproximada de las demás covariables, la varianza del estimador de $b_j$ Si $R^{2}_{j} \rightarrow 1$, entonces $V(\hatb_{j})\rightarrow \infty$.

La multicolinealidad también produce que los estimadores $\hatb_{j}$, para $j=1,\ldots,p-1$, sean muy grandes en valor absoluto. Considere: 
$$
L_{1}^{2} = (\hatbb - \bb)'(\hatbb - \bb) = \sum_{j=1}^{p}(\hatb_{j}-b_{j})^{2}.
$$ 
El valor esperado de $L_{1}^{2}$ es:
$$
E(L_{1}^{2}) = \sum_{j=1}^{p-1}E(\hatb_{j}-b_{j})^{2} = \sum_{j=1}^{p-1}\sigma^{2}\tr\bR^{-1}
$$
Dado que la traza de una matriz es igual a la suma de sus valores propios, tenemos que:
$$
E(L_{1}^{2}) = \sigma^{2}\sum_{j=1}^{p-1}1/\lambda_{j},
$$
donde $\lambda_{j} > 0$, para $j=1,\ldots,p-1$, son los valores propios de $\bR$. Por lo tanto, si $\bR$ está mal condicionada debido a la multicolinealidad, al menos un $\lambda_{j}$ será muy pequeño.

Cabe notar que, la multicolinealidad no viola ningún supuesto sobre los errores. Por lo tanto los estimadores por MCO siguen siendo BLUE. Pero, en presencia de multicolinealidad:

- Las varianzas de los coeficientes $(\hatbeta_{j})$ se incrementan. Lo que reduce los valores $t$ asociados.

- Los $\hatbeta_{j}$ son sensibles a las especificaciones. Estos pueden cambiar drásticamente cuando se agregan o eliminan covariables.

- El ajuste general del modelo, y por lo tanto los pronósticos y las predicciones, no se verá afectado en gran medida. Pero los intervalos de confianza que se calculen pueden ser muy amplios.

### Causas de la multicolinealidad
La multicolinealidad se puede deber a múltiples razones, entre las que están:

- Con frecuencia se presentan problemas donde intervienen procesos de producción o químicos, donde los regresores son los componentes de un producto y ésos suman una constante.

- Variables que son componentes de un sistema pueden mostrar dependencias casi lineales debido a las limitaciones biológicas, físicas o químicas del sistema.

- Variables que tienen una tendencia común y evolucionan de forma muy parecida en el tiempo.

- Inclusión de variables irrelevantes en el modelo. La información que contienen estas variables ya estarían incluidas en otras y no aportan a la explicación de la variabilidad de la variable respuesta.

Por ejemplo, en los datos del cemento, tenemos que el problema de multicolinealidad se presenta porque:
$$
x_{i1} + x_{i2} + x_{i3} + x_{i4} \approx \mbox{constante}.   
$$
En los datos de grasa corporal, el problema es causado por la alta correlación entre el pliegue cutáneo del triceps $(X_{1})$ y la circunferencia del muslo $(X_{2})$.

## Detección de multicolinealidad
Dado que la multicolinealidad provoca una inflación de la varianza, un indicio de este problema esta en que aunque el modelo presenta un buen ajuste (un $R^2$ por ejemplo), las estimaciones de coeficientes asociados a covariables releventas tienen valores $t$ pequeños. Además, al eliminar covariables, las estimacioes cambian considerablemente. 

Los métodos mas usados para detectar multicolinealidad son:

- la matriz de correlación de las covariables.

- los factores de inflación de varianza.

- los índices de condiciones de $\bR$ o $\bZ$.

### Factores de inflación de varianza
Dado que $V(\hatbb) = \sigma^2\bR^{-1}$, la diagonal de $\bR^{-1}$ es un buen indicador de multicolinealidad:
$$
\{\bR^{-1}\}_{jj} = (1-R_{j}^{2})^{-1},
$$
donde $R_{j}^{2}$ es el coeficiente de determinación de ajustar un modelo de $x_{j}$ en función de las demás covariables. Si $x_{j}$ es casi ortogonal a las demás covariables, $R^{2}_{j}$ es pequeño, y por lo tanto, $\{\bR^{-1}\}_{jj}$ cercano a $1$. Mientras que, si $x_{j}$ es casi linealmente dependiente a las demás covariables, entonces $R^{2}_{j}$ es cercano a $1$ y $\{\bR^{-1}\}_{jj}$ grande.

Es decir, $\{\bR^{-1}\}_{jj}$ puede ser visto como un factor de cuanto se incrementa $V(\hatb_{j})$ debido a la colinealidad entre las covariables. De aquí el nombre de factor de inflación de varianza (VIF). Generalmente, uno o mas valores grandes de VIF ($5$ o $10$) es un indicador de problemas de multicolinealidad.

### Valores propios de $\bZ'\bZ$
Dado que $\bR = \bZ'\bZ$ es una matriz simétrica y positiva semi-definida, entonces se puede descomponer:
$$
\bR = \bT\bLambda\bT',
$$
donde $\bT = (\bt_{1},\ldots,\bt_{k})$ es una matriz ortogonal de vectores propios, y $\bLambda$ una matriz diagonal con los valores propios $\lambda_{j}$, para $j=1,\ldots,p-1$, en la diagonal principal. Por lo tanto,
$$
V(\hatbbeta) = \sigma^{2}\bT \bLambda^{-1}\bT'.
$$
Entonces, 
$$
V(\hatb_{j}) = \sigma^{2}\sum_{k=1}^{p-1}\frac{t_{jk}^{2}}{\lambda_{k}}.
$$
De la expresión anterior,
$$
VIF_{j} = \sum_{j=1}^{p-1}\frac{t_{ij}^{2}}{\lambda_{j}},
$$
Por lo tanto, uno o más valores propios pequeños pueden inflar la varianza de $\hatb_{j}$. De aquí salen los indicadores llamados índices de condición y número de condición.

El índice de condición está definido como:
$$
\eta_{j} = \frac{\lambda_{\mbox{max}}}{\lambda_{j}}.
$$
El número de condición está definido como el máximo índice de condición. Un número de condición mayor de 100 es un indicador de multicolinealidad.

### Valores singulares de $\bZ$
El número de condición también se puede calcular a partir de la descomposición en valores singulares (SVD) de la matriz de covariables $\bZ$. Esto es:
$$
\bZ =\bU\bD\bT',
$$
donde $\bU$ y $\bT$ son matrices $n\times (p-1)$ y $(p-1)\times (p-1)$, respectivamente, $\bU\bU = \bI$ y $\bT'\bT = \bI$, y $\bD$ es una matriz diagonal con elementos $\mu_{j}$, $j=1,\ldots,p-1$, llamados valores singulares. 

Hay una relación entre los valoes singulares de $\bZ$ y los valores propios de $\bZ'\bZ$:
$$
\bZ'\bZ = (\bU\bD\bT')'\bU\bD\bT' = \bT\bD^2\bT' = \bT\bLambda\bT'.
$$
El índice de condición de $\bZ$ está definido como:
$$
\kappa_{j} = \frac{\mu_{\mbox{max}}}{\mu_{j}}.
$$
El número de condición de $\bZ$ está definido como el máximo $\kappa_{j}$. Un número de condición mayor de 10,15 o 30 es un indicador de problemas de multicolinealidad.

Note que $\kappa_{j} = \sqrt{\eta_{j}}$. Por lo que el punto de corte de $10$ para el número de condición de $\bZ$ es equivalente al número de condición de $100$ para el número de condición de $\bZ'\bZ$.

### Proporciones de descomposición de varianza
Hay una relación entre el VIF, los valores propios y los valores singulares. Esta es:
$$
VIF_{j} = \sum_{j=1}^{p-1}\frac{t_{ij}^{2}}{\lambda_{j}} = \sum_{j=1}^{p-1}\frac{t_{ij}^{2}}{\mu_{j}^2}.
$$
De aquí salen los indicadores llamados proporciones de descomposición de varianza. Estos se calculan de la siguiente forma:
$$
\pi_{ij} = \frac{t_{ij}^2 / \mu_{i}^2 }{VIF_{j}}, j = 1,\ldots, p-1.
$$
Si se agrupan los $\pi_{ij}$ en una matriz $(p-1) \times (p-1)$ $\bpi$, la columna $j$ son proporciones de la varianza de $\hatbb$. Valores $\pi_{ij}$ mayores de 0.5 indican problemas de multicolinealidad.  

## Datos de cemento
Los VIF para el modelo ajustado para los datos de cemento son los siguientes:
```{r CementVIF, echo=T, warning=FALSE,message = FALSE}
car::vif(mod.cement)
```
Aquí vemos que todos los VIFs son muy altos, mostrando que hay problemas graves de multicolinealidad.

Para calcular los índices de condición (a partir de los valores singulares de $\bZ$) y las proporciones de descomposición de varianza se utiliza la función ``colldiag()`` de la librería ``perturb``:
```{r CementIindiceCondicion,echo=T, warning=FALSE,message = FALSE}
library(perturb)
colldiag(mod.cement,scale = TRUE,center = TRUE,add.intercept = FALSE)
```
El número de condición $(37.106)$ es muy alto reafirmando el problema de multicolinealidad. Además, también se puede observar que varias de las proporciones de descomposición de varianza son mayores de $0.5$.

## Datos de grasa corporal
Para el modelo ajustado a losdatos de grasa corporal, los VIFs son:
```{r BodyfatVIF, echo=T, warning=FALSE,message = FALSE}
car::vif(mod.bodyfat)
```
Además, los índices de condición y las proporciones de descomposición de varianza son:

```{r BodyfatIindiceCondicion,echo=T, warning=FALSE,message = FALSE}
library(perturb)
colldiag(mod.bodyfat,scale = TRUE,center = TRUE,add.intercept = FALSE)
```
Todos estos indicadores muestran que hay problemas de multicolinealidad.

## Solución al problema de multicolinealidad
Una forma sencilla de resolver los problemas de multicolinealidad son:

- la recolección de datos adicionales: si se tiene control sobre las covariables, es posible tomar más observaciones para romper con la casi dependencia en $\bX$. Pero esto en muchas casos es díficl por la naturaleza de las covariables. Por ejemplo, sería imposible buscar personas con circunferencia del muslo grande y pliegue cutáneo del tríceps bajo (o viceversa). 

- la re-especificación del modelo: se pueden eliminar del modelo las covariables que me generan el problema de multicolinealidad y que pueden tener poco aporte explicativo dentro del modelo. 

```{r BodyfatFit0, echo=F, warning=FALSE,message = FALSE}
mod.bodyfatSummary = summary(mod.bodyfat)
mod.bodyfat0 = lm(Fat ~ Triceps+Midarm,data=bodyfat)
mod.bodyfat0Summary = summary(mod.bodyfat0)
```

Por ejemplo, en los datos de la grasa corporal podemos eliminar la variable asociada al muslo (o al tríceps, pues ambas proporcionan la misma información). Si quitamos esta covariable:
```{r BodyfatFit2, echo=T, warning=FALSE,message = FALSE}
mod.bodyfat0 = lm(Fat ~ Triceps+Midarm,data=bodyfat)
car::vif(mod.bodyfat0)
```

los VIFs disminuyen considerablemente. Además, no hay una reducción notable del $R^2$. Con las tres covariables temenos que $R^{2}=`r round(mod.bodyfatSummary$r.squared,3)`$. Mientras que al remover ``Thigh``, tenemos que $R^{2} = `r round(mod.bodyfat0Summary$r.squared,3)`$


Considerando que el estimador por MCO es el mejor estimador lineal insesgado de $\bbeta$, podemos relajar la condición de insesgamiento y buscar estimadores que aunque sean sesgados tengan menor varianza que los estimadores por MCO. 


Dos de estas alternativas son:

- Estimador de ridge.

- Estimadores por componentes principales.


## Estimador de ridge
El estimador de ridge tiene como objetivo minimizar la siguiente suma de cuadrados penalizada:
\begin{equation}
\begin{split}
S_{R}(\bb) &= \sum_{i=1}^{n}(y_{i} - \bz_{i}'\bb)^{2} + k \sum_{j=1}^{p-1}\bb_{j}^2 \\
&= (\by - \bZ\bb)'(\by - \bZ\bb) + k ||\bb||_{2}^{2},
\end{split}
\nonumber
\end{equation}
con $k \geq 0$ (el cual es seleccionado por el investigador). Lo que lleva a las siguientes ecuaciones normales:
\[
(\bR + k \bI)\hatbb_{R} = \bZ'\by.
\]
La solución de las ecuaciones normales lleva al estimador ridge:
\[
\hatbb_{R} = (\bR + k \bI)^{-1}\bZ'\by.
\]
Note que, incluso si $\bR$ es no es invertible, un $k > 0$ resuelve el problema. Además, la solución depende de $k$ (por cada $k$, hay una estimación diferente). 

$k$ es un parámetro de contracción:

- si $k \rightarrow 0$, encontramos que $\hatbb_{R} \rightarrow \hatbb$.
- si $k \rightarrow \infty$, encontramos que $\hatbb_{R} \rightarrow \bZERO$ (excepto el intercepto).

Ahora veamos las propiedades del estimador de ridge. El valor esperado de $\hatbb_{R}$ es:
$$
E(\hatbb_{R}) = (\bR + k \bI)^{-1}\bR \bb.
$$
De aquí vemos que $\hatbb_{R}$ es sesgado, y aumenta con $k$ (por lo que este parámetro también es llamado de sesgo). La varianza de $\hatbb_{R}$ es:
$$
V(\hatbb_{R}) = \sigma^{2}(\bR + k \bI)^{-1}\bR(\bR + k \bI)^{-1}.
$$
A partir de las cantidades anteriores se puede determinar el error cuadrático medio (ECM) de $\hatbb_{R}$:
\begin{equation}
\begin{split}
\mbox{ECM}(\hatbb_{R}) &= \sigma^{2}\tr [(\bR + k\bI)^{-1}\bR(\bR + k\bI)^{-1}] + k^{2}\bb'(\bR + k\bI)^{-2}\bb \\
&=\sigma^{2}\sum_{i=1}^{p-1}\frac{\lambda_{j}}{(\lambda_{j}+ k)^2} + k^{2} \bb'(\bR + k\bI)^{-2}\bb,
\end{split}
\nonumber
\end{equation}
donde $\lambda_{1},\ldots,\lambda_{k}$ son los valores propios de $\bR$.

Finalmente, la suma de cuadrados de los residuos usando $\hatbb_{R}$ es:
$$
\Sres = (\by - \bX\hatbb)'(\by - \bX\hatbb) + (\hatbb_{R}-\hatbb)'\bR(\hatbb_{R}-\hatbb).
$$
A partir de estos resultados, vemos que: (1) Si $k$ crece, disminuye la varianza, pero aumenta el sesgo. (2) Si $k$ disminuye, aumenta la varianza, pero disminuye el sesgo. (3) el estimador ridge proporciona un $R^{2}$ mas pequeño que el estimador por MCO. Además, $R^2$ disminuye con $k$. Sin embargo, la regresión ridge proporciona estimaciones de $\bb$ más estables.

La idea de la regresión de ridge es encontrar un valor de $k$ tal que  $\mbox{ECM}(\hatbb_{R}) < V(\hatbb)$. En la Figura \@ref(fig:ECMrepresentacion) podemos ver la representación del ECM del estimador de ridge. Aquí vemos que a medida que aumenta $k$, el sesgo incrementa y la varianza disminuye. También, hay una región de $k$ donde se puede obtener un ECM del estimador de ridge menor que el que se obtiene por medio de MCO. La idea es encontrar el valor de $k$ que minimiza el ECM, o por lo menos algún valor en la región donde $\mbox{ECM}(\hatbb_{R}) < V(\hatbb)$.


```{r ECMrepresentacion, echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Representación del sesgo al cuadrado (linea cortada), varianza (linea punteada) y error cuadrático medio (linea solida) del estimador de ridge. La linea roja representa el error cuadrático medio del estimador por MCO.",warning=FALSE,message = FALSE}
x= seq(from=0,to=0.3,length.out = 100)
sesgo = 0.25/(1+exp(-20*(x-0.001)))
sesgo = sesgo - min(sesgo) 
vari = 0.06*exp(-70*x)+ 0.0025
ecm =sesgo+vari
plot(x,sesgo,type = 'l',xlim=c(0,0.2),ylim=range(c(sesgo,vari,ecm)),lty=2, xaxt='n',yaxt='n',
     xlab='k',ylab='Sesgo, varianza y MSE')
lines(x,vari,lty=3)
lines(x,ecm,lwd=2)
abline(h=max(vari),col=2)
lines(c(x[ecm==min(ecm)],x[ecm==min(ecm)]),c(-1,min(ecm)),col=4)
lines(c(-1,x[ecm==min(ecm)]),c(min(ecm),min(ecm)),col=4)
axis(1,x[ecm==min(ecm)],'k óptimo')
```
Algunos métodos de selección de $k$ son:

- Traza de ridge $k$: el efecto de $k$ sobre las estimaciones de $\hatbb_{R}$ es mas fuerte para valores bajos. De igual forma, si $k$ es muy grande introducimos mucho sesgo. Por lo que se puede hacer es incrementar $k$ hasta que parezca que su influencia sobre $\hatbb_{R}$ se atenúe.

- Validación cruzada (CV): sea $\haty_{(i),k}$ la estimación de $E(y_i)$ por medio del estimador de ridge con el parámetro $k$ y usando una muestra excluyendo la i-ésima observación. La validación cruzada está definida como:
$$
CV(k) = \sum_{i=1}^{n} (y_i - \haty_{(i),k})^2.
$$
Por lo que la selección de $k$ es:
$$
k_{CV} = \arg \min_{k} CV(k).
$$

### Datos de cemento
Para ajustar el modelo usando el estimador de ridge podemos usar la función ``lmridge`` del paquete ``lmridge``. Primero, ajustamos el modelo usando diferentes valores de $k$:
```{r cementridge1,echo=T, warning=FALSE,message = FALSE}
library(lmridge)
K = seq(from=0,to=0.3,length.out = 100)
ridge.cement = lmridge(y~., data=cement,K=K,scaling='sc')
```
En el objeto ``ridge.cement`` tenemos las estimaciones por el estimador de ridge para $100$ valores de $k$ entre $0$ y $0.3$. Para observar como cambian las estimaciones para los diferentes valores de $k$ podemos graficar la traza de ridge así (en términos de las covariables en su escala orginal):
```{r CementTrazaRidge,echo=T, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "Datos de cemento. Traza de ridge. Coeficiente asociado a ``X1`` (negro), coeficiente asociado a ``X2`` (rojo), coeficiente asociado a ``X3`` (verde) y coeficiente asociado a ``X4`` (azul)",warning=FALSE,message = FALSE}
EstRidge.cement = coef(ridge.cement)
plot(K,EstRidge.cement[,2],type='l',ylim=range(EstRidge.cement[,-1]),lwd=2,
     ylab='Estimaciones de los coeficientes',xlab='k')
lines(K,EstRidge.cement[,3],col=2,lwd=2)
lines(K,EstRidge.cement[,4],col=3,lwd=2)
lines(K,EstRidge.cement[,5],col=4,lwd=2)
abline(h=0,lty=2)
```
En la Figura \@ref(fig:CementTrazaRidge) podemos observar que, cuando incrementamos $k$, las estimaciones cambian rápidamente y luego parecen estabilizarse cuando $k$ es grande. Además hay un cambio de signo para el coeficiente asociado a ``X3``. También puede usarse ``plot(mod.r)`` (traza de ridge para las estimaciones de los coeficientes asociados a las covariables escaladas).

La selección del $k$ óptimo por medio de validación cruzada (CV) se hace de la siguiente manera:
```{r cementridge3, fig.height = 4, fig.width = 6,fig.align = "center",fig.cap = "\\label{fig:CementCVridge} Datos de cemento. Validación cruzada.",warning=FALSE,message = FALSE}
Criterios.cement = kest(ridge.cement)
plot(K,Criterios.cement$CV,type='l',xlab='K',ylab='validación cruzada')
K[Criterios.cement$CV==min(Criterios.cement$CV)]
```
Aquí podemos ver que el valorde $k$ que minimiza la validación cruzada es $0.009$. El valor óptimo de $k$ por medio de otros criterios son: 
```{r cementridge4,echo=T, warning=FALSE,message = FALSE}
Criterios.cement
```
La estimación con $K=0.0101$ se puede obtener usando la función ``lmridge`` usando $K=0.0101$ como argumento:
```{r cementridge5,echo=T, warning=FALSE,message = FALSE}
ridge.cement2 = lmridge(y~., data=cement,K=0.0101,scaling='sc')
summary(ridge.cement2)
```
Vemos algunas diferencias con las estimaciones por MCO. Hay un cambio de signo en la estimación del coeficiente asociado a ``x3``. Si embargo, no hay mucha diferencia en las estimaciones de los otros coeficientes. También podemos observar que las covariables ``x1``, ``x2`` y ``x3`` ahora tienen un aporte significativo. Como era de esperarse, hay una disminución del $R^{2}$, sin embargo es muy leve.

## Estimador por componentes principales
Considere el modelo en su forma canónica:
$$
\by^{*} = \bZ\bT\balpha + \bvarepsi,
$$
donde $\balpha = \bT'\bb$, $(\bZ\bT)'\bZ\bT=\bLambda$, $\bLambda$ es una matriz diagonal de valores propios $(\lambda_1,\ldots,\lambda_p)$ de $\bZ'\bZ$, y $\bT = (\bt_{1},\ldots,\bt_{p-1})$ es la matriz ortogonal de vectores propios asociados $\bLambda$.

Las columnas de $\bP = \bZ\bT = (\bp_{1},\ldots,\bp_{p-1})$ son un conjunto de regresores ortogonales(llamados componentes principales):
$$
\bp_{k} = \sum_{j=1}^{p-1} t_{kj}\bz_{j}.
$$
El estimador de $\balpha$ por MCO es:
$$
\hatbalpha = (\bP'\bP)^{-1}\bP'\by^{*} = \bLambda^{-1}\bP'\by^{*},
$$
y la varianza de $\hatbalpha$ es:
$$
V(\hatbalpha) = \sigma^{2}(\bP'\bP)^{-1} = \sigma^{2}\bLambda^{-1}.
$$
De aquí podemos ver que valores propios de $\bZ'\bZ$ están asociados con la varianza de los coeficientes de regresión. Si $\lambda_j=1$ (para $j=1,\ldots,p$), las covariables originales son ortogonales. Mientras que valores propios cercanos a cero indican problemas de multicolinealidad dado que inflan la varianza de $\hatbalpha$. 

Además, Note que para $\hatbb = \bT\hatbalpha$, tenemos:
$$
V(\hatbb) = V(\bT\hatbalpha) =\sigma^{2}\bT\bLambda^{-1}\bT' = \sigma^{2} \sum_{j=1}^{p-1}\lambda_{j}^{-1}\bt_{j}\bt_{j}',
$$
lo que implica que $V(\hatb_{k}) = \sigma^{2} \sum_{j=1}^{p-1}t_{kj}^{2}/\lambda_{j}$; la varianza de $\hatb_j$ es una combinación lineal de los valores propios.

Para combatir el problema de multicolinealidad, la idea de la regresión por componentes principales es usar un subconjunto de $\bP$ como regresores (en vez de todos los compontes). Para esto, eliminamos los componentes principales $(\bp_{r+1},\ldots,\bp_{p-1})$ asociados a los valores propios cercanos a cero $(\lambda_{r+1},\ldots,\lambda_{p-1})$. Aquí estamos asumiendo que los valores propios están ordenados de mayor a menor, $\lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_p$ (como lo hace `R`). Esto es,
$$
\hatbalpha_{PC} = \bL \hatbalpha = \begin{pmatrix} \bI_{r} & \bZERO \\ \bZERO & \bZERO \end{pmatrix} \hatbalpha.
$$
Por lo tanto $\hatbalpha_{PC} = (\overbrace{\hatalpha_{1},\hatalpha_{2},\ldots, \hatalpha_{r}}^{r},\overbrace{0, \ldots,0}^{p-1-r})'$. 

En términos de $\bb$, 
\[
\hatbb_{PC} = \bT\hatbalpha_{PC} = \bT\bL\bLambda^{-1}\bT'\bZ'\by^{*}.
\]
Además,
\[
V(\hatbb_{PC}) = \sigma^{2} \bT\bL\bLambda^{-1}\bL'\bT' = \sigma^{2}\sum_{j=1}^{r} \lambda_{j}^{-1}\bt_{j}\bt_{j}'.
\]
lo que implica que $V(\hatb_{PC,j}) = \sigma^{2} \sum_{k=1}^{r}t_{jk}^{2}/\lambda_{k}$.

El sesgo de $\hatbb_{PC}$ está definido como:
$$
E(\bT\hatbalpha_{PC}) - \bT\balpha = -\sum_{k=r+1}^{p-1}\alpha_k\bt_{k}.
$$
Mientras que la varianza de $\hatbb_{PC}$ es:
\begin{equation}
V(\bT\hatbalpha_{PC}) = \bT \left[ \sigma^{2}\bL \bLambda^{-1} \bL \right] \bT^{-1} = \sigma^{2} \sum_{k=1}^{r}\lambda_k^{-1}\bt_{k}\bt_{k}' \leq \sigma^{2} \sum_{k=1}^{p-1}\lambda_k^{-1}\bt_{k}\bt_{k}' = \sigma^{2}(\bZ'\bZ)^{-1}.
(\#eq:varBPC)
\end{equation}
Por lo tanto, al eliminar componentes principales se aumenta el sesgo, pero se disminuye la varianza de $\hatbb_{PC}$.

Note en \@ref(eq:varBPC) que la diferencia en varianzas con respecto al estimador de MCO de $\bb$:
$$
\sigma^{2}\sum_{k=r+1}^{p-1}\lambda_k^{-1} \bt_{k}\bt_{k}',
$$
será mayor si las componentes principales excluidas están asociadas a valores propios pequeños.

### Datos de cemento
Antes de ajustar el modelo vamos a escalar las variables
```{r cementRCP,echo=T, warning=FALSE,message = FALSE}
escalar <- function(x) {(x-mean(x)) / sqrt(sum((x-mean(x))^2))}
X = as.matrix(cement[,1:4])
y.e = escalar(cement$y)
Z = apply(cement[,1:4],2,escalar)
```
A partir de las variables escaladas podemos calcular los vectores y valores propios:
```{r cementRCP2,echo=T, warning=FALSE,message = FALSE}
T.mat = eigen(t(Z)%*%Z)$vectors
lambda = eigen(t(Z)%*%Z)$values
lambda
```
Aquí podemos observar que un valor propio es cercano a cero, por lo que lo podemos eliminarlo para remediar el problema de multicolinealidad:
```{r cementRCP3,echo=T, warning=FALSE,message = FALSE}
P = Z%*%T.mat
PCR.cement = lm(y.e~P[,-4]-1)
summary(PCR.cement)
```
Las estimaciones de los coeficientes $(\bb)$ para las variables escaladas:
```{r cementRCP4,echo=T, warning=FALSE,message = FALSE}
beta.CP =T.mat%*%c(PCR.cement$coefficients,0)
beta.CP
```
La matriz de varianza de $\bb_{PC}$ es:
```{r cementRCP5,echo=T, warning=FALSE,message = FALSE}
sigma2.pc = sum(PCR.cement$residuals^2)/(13-4)
Var.b = sigma2.pc*T.mat%*%diag(c(1/lambda[1:3],0))%*%t(T.mat)
Var.b
```

<!--chapter:end:03-Multicolinealidad.Rmd-->

# Selección de variables
```{r preamble4, include=FALSE}
library(glmnet)
library(olsrr)
library(kableExtra)
```

## Ejemplos
### Unidad quirúrgica
Una unidad quirúrgica de un hospital está interesada en predecir la supervivencia de los pacientes sometidos a un tipo particular de operación hepática. Se dispuso de una selección aleatoria de $108$ pacientes para el análisis. De cada registro del paciente, se extrajo la siguiente información de la evaluación preoperatoria:

- ``bcs``: coagulación sanguínea.

- ``pindex``: índice de pronóstico.

- ``enzyme``: función enzimática.

- ``liver_test``: función hepática.

- ``age``: edad.

- ``gender``: genero (0 = masculino, 1 = femenino).

- ``alc_mod``: historial de consumo de alcohol (0 = Ninguno, 1 = Moderado).

- ``alc_heavy``: & historial de consumo de alcohol (0 = Ninguno, 1 = Fuerte).

- ``y``: tiempo de supervivencia.

El objetivo del estudio es determinar los factores que influyen sobre el tiempo de supervivencia (que se determinó posteriormente) en función de las demás variables. 

El modelo propuesto es el siguiente:
\begin{equation}
\begin{split}
\log y_{i} =& \beta_{0}+\mbox{bcs}_{i}\beta_{1} + \mbox{pindex}_{i}\beta_{2}+ \mbox{enzyme}_{i}\beta_{3} +  \mbox{liver}_{i}\beta_{4} + \mbox{age}_{i}\beta_{5} +  \mbox{gender}_{i}\beta_{6}+ \\ & \mbox{alc_mod}_{i}\beta_{7} + \mbox{alc_heavy}_{i}\beta_{8} + \varepsilon_{i}
\end{split}
\nonumber
\end{equation}

El ajuste del modelo es:
```{r surgicalFit, echo=T, warning=FALSE,message = FALSE}
library(olsrr)
data(surgical)
mod.surgical.completo = lm(log(y)~.,data=surgical)
summary(mod.surgical.completo)
```


### Grasa corporal
La medición de la grasa corporal es un proceso complejo. Dado que los músculos y los huesos son más densos, el calculo de \% de grasa corporal se basa, entre otros aspectos, en la medición de la densidad corporal la cuál requiere sumergir a las personas en el agua.

Por esta razón se quiere buscar un método más sencillo para determinar el \% de grasa corporal. Para esto, se registraron la edad, el peso, la altura y $10$ medidas de la circunferencia corporal de $252$ hombres. De igual forma, a cada uno de estos hombres se les midió el \% de grasa corporal de forma precisa (usando la ecuación de Brozek, medición a partir de la densidad).

Cómo variable respuesta se utiliza la medición por el método de Brozek, y las posibles covariables son:

- ``age``: edad (en años).

- ``weight``: peso (en libras).

- ``height``: altura (en pulgadas).

- ``neck``: circunferencia del cuello (en centímetros).

- ``chest``: circunferencia del pecho (en centímetros).

- ``abdom``: circunferencia del abdomen (en centímetros).

- ``hip``: circunferencia de la cadera (en centímetros).

- ``thigh``:circunferencia del muslo (en centímetros).

- ``knee``:circunferencia de la rodilla (en centímetros).

- ``ankle``:circunferencia del tobillo (en centímetros).

- ``biceps``: circunferencia del bíceps extendido (en centímetros).

- ``forearm``: circunferencia del antebrazo (en centímetros).

- ``wrist```: circunferencia de la muñeca (en centímetros).

El modelo propuesto es el siguiente:
$$
\mbox{brozek}_i = \beta_{0} + \mbox{age}_i\beta_1+ \mbox{weight}_i\beta_2 + \ldots + \mbox{wrist}_i\beta_{13}  + \varepsilon_i.
$$
El ajuste del modelo es:
```{r fatFit, echo=T, warning=FALSE,message = FALSE}
library(faraway)
data(fat)
mod.fat <- lm(brozek ~ age + weight + height + neck + chest + abdom +
             hip + thigh + knee + ankle + biceps + forearm + wrist, data=fat)
summary(mod.fat)
```

## Problema de selección de variables
En problemas de regresión se tiene un conjunto grande de potenciales covariables. Si ajustamos un modelo considerandolas todas podemos estar incluyendo covariables que son irrelevante. Por el otro lado, si no las incluimos todas es posible que estemos omitiendo covariables importantes. En ambos casos hay consecuencias negativas.

Para illustrar esto, considere el siguiente modelo:
\begin{equation}
\begin{split}
y_{i} &= \beta_{0} + \sum_{j=1}^{p-1}\beta_{j}x_{ij} + \varepsilon_{i} \\
&= \beta_{0} + \sum_{j=1}^{r}\beta_{j}x_{ij} + \sum_{j=r+1}^{p-1}\beta_{j}x_{ij} + \varepsilon_{i} \\
&= \bx_{1i}'\bbeta_1 + \bx_{2i}'\bbeta_2 + \varepsilon_i,
\end{split}
\label{eq:modelogral}
\end{equation}
donde $\bx_{1i} = (1,x_{1i},x_{2i},\ldots,x_{ri})$, $\bx_{2i} = (x_{r+1,i},x_{r+2,i},\ldots,x_{p-1,i})$, $\bbeta_1 = (\beta_0,\beta_1,\beta_2,\ldots,\beta_r)'$, $\bbeta_2 = (\beta_{r+1},\beta_{r+2},\ldots,\beta_{p-1})'$, y $\varepsilon_i \sim N(0,\sigma^{2})$. Es decir, se hace una partición de las covariables y los coeficientes de regressión en dos componentes. 

En forma matricial, el modelo es:
\[
\by = \bX_{1}\bbeta_{1} + \bX_{2}\bbeta_{2}+ \bvarepsi,
\]
donde $\bX_{1}$ es una matriz $n \times r$ con la $i$-ésima fila igual a $\bx_{1i}$ y $\bX_{2}$ es una matriz $n \times (p-r-1)$ con la $i$-ésima fila igual a $\bx_{2i}$.

### ¿Qué pasa si ignoramos covariables importantes?
Ahora, considere que el modelo de regresión real es \@ref(eq:modelogral), pero decidimos estimar:
$$
y_{i} = \bx_{1i}'\bbeta_1 + \varepsilon_i.
$$
Por lo tanto, estamos omitiendo las covariables $\bx_{2i}$ del modelo (puesto que $\bbeta_2 \neq 0$).

El estimador por MCO de $\bbeta_1$ es: 
$$
\hatbbeta_{1} = (\bX_{1}'\bX_{1})^{-1}\bX_{1}'\by.
$$
De aquí tenemos que $E(\hatbbeta_{1}) = \bbeta_{1} + (\bX_{1}'\bX_{1})^{-1}\bX_{1}'\bX_{2}\bbeta_{2}$. Es decir que $\hatbbeta_{1}$ es un estimador sesgado, a menos que  $\bX_{1}'\bX_{2} = \bZERO$ (las columnas de $X_{1}$ son ortogonales a las columnas de $X_{2}$). 

De igual forma, las predicciones también serán sesgadas. La predicción en el punto $\bx_{01}$ es:
$$
\haty_{0} = \bx_{01}'\hatbbeta_{1}.
$$
Su valor esperado es:
$$
E(\haty_{0}) = \bx_{01}'\bbeta_{1} + \bx_{01}'(\bX_{1}'\bX_{1})^{-1}\bX_{1}'\bX_{2}\bbeta_{2} \neq \bx_{01}'\beta_{1} + \bx_{02}'\beta_{2}.
$$
Por lo tanto, si omitimos variables relevantes obtenemos sesgo en las estimaciones.

### ¿Que pasa si incluimos covariables irrelevantes?
Ahora, consideremos el caso en que $\bbeta_2=0$, es decir, las covariables $\bx_{2}$ no tienen un aporte significativo en el modelo. Pero decidimos estimar el modelo completo.

En este caso, el estimador de $\bbeta$ es:
$$
\hatbbeta = (\bX'\bX)^{-1}\bX'\by = \begin{pmatrix}
\bX_{1}'\bX_{1} & \bX_{1}\bX_{2} \\ \bX_{2}'\bX_{1} & \bX_{2}'\bX_{2}
\end{pmatrix}^{-1} \begin{pmatrix}
\bX_{1}' \\ \bX_{2}'
\end{pmatrix}\by.
$$
El Valor esperado de $\hatbbeta$ es:
\begin{equation}
\begin{split}
E(\hatbbeta) =& (\bX'\bX)^{-1}\bX'E(\by) = (\bX'\bX)^{-1}\bX'\bX_{1}\bbeta_1 \\
 = & (\bX'\bX)^{-1}\bX'(\bX_{1} \ \bX_{2}) \begin{pmatrix}
 \bbeta_1 \\ \bZERO
 \end{pmatrix} = \begin{pmatrix}
 \bbeta_1 \\ \bZERO
 \end{pmatrix}.
\end{split}
\nonumber
\end{equation}
Es decir que $\hatbbeta$ es un estimador insesgado. 

La varianza de $\hatbbeta$ es:
\begin{equation}
\begin{split}
V(\hatbbeta) =& \sigma^{2}(\bX'\bX)^{-1} = \sigma^{2}\begin{pmatrix}
\bX_{1}'\bX_{1} & \bX_{1}\bX_{2} \\ \bX_{2}'\bX_{1} & \bX_{2}'\bX_{2}
\end{pmatrix}^{-1} \\
=& \sigma^{2} \begin{pmatrix}
(\bX_{1}'\bX_{1})^{-1} + \bL\bM\bL & - \bL\bM \\
-\bM\bL' & \bM
\end{pmatrix},
\end{split}
\nonumber
\end{equation}
donde $\bL= (\bX_{1}'\bX_{1})^{-1}\bX_{1}'\bX_{2}$ y $\bM = \bX_{2}'(\bI - \bH_{1})\bX_{2}$. Particularmente, para $\hatbbeta_1$ tenemos que:
$$
V(\hatbbeta_{1}) = \sigma^{2} \left[ (\bX_{1}'\bX_{1})^{-1} + \bL\bM\bL \right].
$$
Dado que $\bM$ (y por lo tanto $\bL\bM\bL$) es positiva-definida, la varianza de $\hatbbeta_{1}$ se infla al incluir las covariables irrelevantes al modelo. La única excepción es cuando $\bX_{1}$ y $\bX_{2}$ son ortogonales ($\bX_{1}'\bX_{2} = \bZERO$).

De igual forma, las predicciones en el punto $\bx_{0}' = (\bx_{01}' \ \bx_{02}')$ son insesgadas:
$$
E(\haty_{0}) = E(\bx_{0}'\hatbbeta) = (\bx_{01}' \ \bx_{02}')\begin{pmatrix}
\bbeta_{1} \\ \bZERO
\end{pmatrix} = \bx_{01}'\bbeta_{1}.
$$
Pero su varianza también se infla debido a incluir las covariables irrelevantes:
$$
V(\haty_{0}) = \sigma^{2} \bx_{0}'(\bX'\bX)^{-1}\bx_{0}.
$$

En conclusión:

- Cuando omitimos covariables relevantes, obtenemos sesgos en las estimaciones.

- Cuando incluimos covariables irrelevantes, se inflan las varianzas de las estimaciones. Adicionalmente, incluir más covariables puede llevar a problemas de multicolinealidad.


## Métodos para la selección de variables
Si tenemos $(p-1)$ covariables, entonces tenemos $(p-1)^2$ potenciales modelos. Por lo que podemos ajustar todos los posibles modelos y hacer una comparación entre ellos usando algunos criterios de decisión.

Existen varios criterios para determinar que modelo es ``mejor'' que otro y este debe escogerse teniendo en cuenta cuál es el objetivo que se tiene al ajustar el modelo (descripción de la relación, predicción, control, etc.). Algunos de estos críterios son:

- Coeficiente de determinación ($R^{2}$ y $R^{2}_{adj}$).
- Estadístico $C_{p}$ de Mallows.
- Estadístico PRESS y el $R^{2}$ de predicción.
- Criterios de información (AIC y BIC).

### Coeficiente de determinación
Esté indicador está definido como:
$$
R^{2} = \frac{\Sreg}{\Stotal} = 1 - \frac{\Sres}{\Stotal}.
$$
El $R^{2}$ cuantifica la cantidad de variabilidad de la variable respuesta que es explicada por el modelo. Se tiene que $0 \leq R^{2} \leq 1$. Valores más cercanos a $1$ implican que el modelo explica gran parte de la variabilidad de $y$. 

Hay que tener en cuenta que el $R^{2}$ siempre crece a medida que se adicionan más covariables al modelo. Por lo tanto, se puede puede agregar regresores hasta el punto en que una covariable adicional no propociona un aumento considerable en el $R^{2}$.

### Coeficiente de determinación ajustado
Para evitar el incoviente del $R^{2}$, se puede utlizar el el coeficiente de determinación ajustado definido como:
$$
R^{2}_{adj} = 1 - \frac{n-1}{n-p}\frac{\Sres}{\Stotal} = 1- \frac{\MSres}{\Stotal/(n-1)} = 1- \frac{n-1}{n-p}(1-R^{2}).
$$
El $R^{2}_{adj}$ no necesariamente aumenta al adicionar nuevos términos al modelo. Este solo aumenta si hay una disminución del $\MSres$.

### C$_p$ de Mallows
Mallows propone un criterio basado en el error cuadrático medio (ECM) de $\haty_i$, esto es:
$$
E[\haty_{i}- E(y_{i})]^2 = [E(y_{i}) - E(\haty_{i})]^2 + V(\haty_{i}),
$$
donde $E(y_{i})$ es el valor esperado de la respuesta ('modelo real'), y $E(\haty_{i})$ es el valor esperado de la respuesta basado en el modelo propuesto (basado en $p$ covariables).

El ECM total estandarizado está definido como:
\begin{equation}
\begin{split}
\Gamma_{p} =& \frac{1}{\sigma^{2}}\left\{\sum_{i=1}^{n}[E(y_{i}) - E(\haty_{i})]^2 + \sum_{i=1}^{n}  V(\haty_{i}) \right\} \\
=&  \frac{1}{\sigma^{2}}\left\{SS_{B}(p)  + \sum_{i=1}^{n}  V(\haty_{i}) \right\} = \frac{1}{\sigma^{2}}\left\{SS_{B}(p)  + p\sigma^{2} \right\} \\
=& \frac{1}{\sigma^{2}}\left\{ E[\Sres(p)] - (n-p)\sigma^{2} + p\sigma^{2} \right\} \\ =& \frac{E[\Sres(p)]}{\sigma^{2}} - n + 2p.
\end{split}
\nonumber
\end{equation}

Reemplazando $E[\Sres(p)]$ por $\Sres(p)$, y asumiendo que $\MSres(p^{*})$ (calculado usando el modelo completo) es un buen estimador de $\sigma^{2}$:
\[
C_{p} = \frac{\Sres(p)}{\MSres(p^{*})} - n + 2p.
\]
Por lo tanto, para el modelo completo $C_{p} = p^{*}$. Si $E[\Sres(p)] = (n-p)\sigma^{2}$ (asumiendo que $SS_{B}(p)=0$), tenemos que:
\[
E[C_{p}| \mbox{Sesgo}=0] = \frac{(n-p)\sigma^{2}}{\sigma^{2}} - n +2p = p.
\]
Si el modelo propuesto es insesgado se espera que el $C_p$ esté cercano a $p$. Aunque se espera que el $C_p=p$, es deseable que $C_p < p$. Por lo tanto, modelos con valores pequeños de $C_p$ son mejores. 

### Estadístico PRESS
El estadístico PRESS (prediction error sum of squares) está definido como: 
$$
\mbox{PRESS} = \sum_{i=1}^{n} (y_{i} - \haty_{(i)})^{2} = \sum_{i=1}^{n} \left( \frac{\epsilon_{i}}{1-h_{ii}} \right)^{2}.
$$
Para comparar modelos, menor valor del PRESS indica que el modelo es mejor para hacer predicciones.

A partir del PRESS se puede calcular el $R^{2}$ de predicción:
$$
R^{2}_{pred} = 1 - \frac{PRESS}{SST}.
$$
Basado en este criterio, mayor es el valor de $R^{2}_{pred}$ mejor es el modelo para hacer predicciones. La ventaja del PRESS y $R_{pred}^{2}$ es que evitan el sobreajuste dado que se calculan utilizando observaciones no incluidas en la estimación del modelo.

### Criterios de información
La idea es comparar modelos estimados teniendo en cuenta la bondad de ajuste del modelo (verosimilitud, $L$) y su complejidad (número de parámetros). El criterio de información de Akaike está definido como:
$$
\mbox{AIC} = -2\log (L) + 2p.
$$
El criterio de información bayesiano (o de Schwarz - SBC):
$$
\mbox{BIC} = -2\log (L) + p\log n.
$$
Es preferible modelos con valores menores de AIC o BIC. Dado que la penalización del BIC es mayor (si $n > 7$), este indicador tiende a preferir modelos con menor número de covariables.

Recordemos que la log-verosimilitud es:
$$
\log L(\bbeta,\sigma^{2}) = - \frac{n}{2}\log (2\pi) - n\log(\sigma) - \frac{1}{2\sigma^{2}}(\by - \bX\bbeta)'(\by-\bX\bbeta).
$$
El estimador por máxima verosimilitud de $\sigma^{2}$ es $\hatsigma=\Sres/n$. Por lo tanto, el máximo valor de la log-verosimilitud es:
$$
\log L(\hatbbeta,\hatsigma^{2}) = -\frac{n}{2}\log (2\pi) - \frac{n}{2}\log\hatsigma^{2} - \frac{1}{2\hatsigma^{2}}\Sres = -\frac{n}{2}\log (\Sres/n) + \mbox{constante}.
$$
Por lo tanto:
$$
AIC \propto n\log(\Sres/n) + 2p \mbox{ y } BIC \propto n\log(\Sres/n) + p\log n.
$$
Hay varias adaptaciones de estos criterios de información definiendo diferentes penalizaciones.

## Comparación de los modelos
### Todos los posibles modelos
Con la función ``ols_step_all_possible()`` de la librería ``olsrr`` es posible ajustar todos posibles modelos y determinar el mejor bajo diferentes criterios. Otra alternativa es la función ``regsubsets()`` de la librería ``leaps``. Está función es más rápida (se basa en un algoritmo más eficiente), pero no es user-friendly.

#### Datos de unidad quirúrgica
A través de la función ``ols_step_all_possible`` podemos ajustar los $255$ modelos que se pueden ajustar usando las ocho posibles covariables:

```{r surgicalFitAll, echo=T, warning=FALSE,message = FALSE}
surgical.all.mods=ols_step_all_possible(mod.surgical.completo)
```
Además de ajustar los modelos, se calculan varios criterios ($R^{2}$,$R^{2}_{adj}$, $R^{2}_{pred}$,AIC,BIC,...) para cada uno de ellos.

Puesto que son muchos modelos, podemos organizar los resultados de tal forma que obtengamos los mejores modelos basándonos en cada uno de los criterios. Por ejemplo, los 5 mejores ajustes según el $R^{2}_{adj}$ son:

```{r surgicalFitAll2, echo=T, warning=FALSE,message = FALSE}
R2adj.order = order(surgical.all.mods$adjr,decreasing = T)
as.data.frame(surgical.all.mods)[R2adj.order[1:5],c(2:8,10)]
```
Entonces, basándonos en el $R^{2}_{adj}$ el mejor ajuste se obtiene con el modelo considerando las covariables ``bcs``, ``pindex``, ``enzyme_test``, ``age``, ``gender``, y ``alc_heavy``. Es decir, eliminando las covariables función hepática y consumo de alcohol moderado. Note que no todos los demás críterios sugieren el mismo modelo. Si eliminamos las covariables ``gender`` obtenemos un modelo con un $R^{2}_{pred}$ más alto.

Ahora, si nos apoyamos en el AIC, los mejores 5 ajustes son: 
```{r surgicalFitAll3, echo=T, warning=FALSE,message = FALSE}
AIC.order = order(surgical.all.mods$aic,decreasing = F)
as.data.frame(surgical.all.mods)[AIC.order[1:5],c(2:8,10)]
```
Con este críterio se escoge el mismo modelo que con el $R^{2}_{adj}$. Sin embargo, podemos observar que el BIC sugiere eliminar la covariable asociada a la edad. 

En la Figura \@ref(fig:surgicalFitAllPlot) muestra los $R^{2}$,$R^{2}_{adj}$, $R^{2}_{pred}$,C$_p$, AIC y BIC (SBC) para todos los posibles ajustes. Note que, dentro de cada subgrupo de modelos (determinado por el número de covariables), los criterios eligen los modelos en el mismo orden. La diferencia está en el número de covariables a elegir. Generalmente, el BIC prefiere modelos más parsimoniosos. Esto no ocurre con criterios de validación cruzada, como el PRESS o $R^{2}_{pred}$.

```{r surgicalFitAllPlot, echo=T, fig.height = 5, fig.width = 7,fig.align = "center",fig.cap = "Valores de los criterios de selección calculados para cada uno de todos los posibles modelos.",warning=FALSE,message = FALSE}
plot(surgical.all.mods)
```

Teniendo en cuenta esto, con la función ``ols_step_best_subset()`` selecciona el mejor modelo para cada subconjunto de número de covariables basándose en los diferentes criterios:

```{r surgicalFitAll4, echo=T, warning=FALSE,message = FALSE}
ols_step_best_subset(mod.surgical.completo)
```

A partir de estos resultados, y con la ayuda de expertos en el tema, se puede hacer una selección del mejor modelo para hacer las predicciónes.

### Algorítmos de selección
Para el proceso de selección, la mejor opción es evaluar todos los posibles modelos. Sin embargo, en la presencia de muchas posibles covariables este proceso puede requerir una carga computacional muy alta. Por esta razón, se han desarrollado varios algoritmos para evaluar solo un subconjunto de modelos agregando o eliminando covariables una a la vez.


#### Selección hacia delante (forward selection)
Este algoritmo parte del modelo sin ninguna covariable (es decir, solo el intercepto) y el ajuste ``óptimo'' se encuentra ingresando covariables una a la vez basándose en algún criterio (por ejemplo AIC).

La primera covariable se escoge luego de ajustar los $(p-1)$ modelos simples con cada uno de los regresores. Por ejemplo, seleccionado la covariable que proporciona el mejor AIC.

Luego se ajustan los modelos combinando la covariable previamente seleccionada con cada una de los restantes $(p-2)$ regresores. Si el mejor ajuste con dos covariables proporcina un menor AIC que en el paso anterior, continuamos seleccinando la tercer covariable de la misma forma. 

El algoritmo continua seleccionando covariables hasta que se satisface un criterio de parada (por ejemplo, hasta que el AIC aumente).

#### Selección hacia atrás (backward selection)
Con este algoritmo se empieza evaluando el modelo con todas las covariables candidatas y se van eliminando covariables una a una hasta que un criterio de parada se satisface (por ejemplo, hasta que el AIC aumenta).

#### Selección por segmentos (stepwise selection)
Aquí se siguen los mismos pasos que la selección hacia delante. Pero en cada paso se evalúan de nuevo los candidatos que ya habían ingresado en el modelo. Por lo tanto, una covariable que ya esté en el modelo puede ser eliminada en algún paso posterior.


#### Unidad quirúrgica
Consideremos el modelo anterior adicionando las interacciones de las covariables continuas con las categóricas:
\begin{equation}
\begin{split}
\log y_{i} =& \beta_{0}+\mbox{bcs}_{i}\beta_{1} + \mbox{pindex}_{i}\beta_{2}+ \mbox{enzyme}_{i}\beta_{3} +  \mbox{liver}_{i}\beta_{4} + \mbox{age}_{i}\beta_{5} +  \mbox{gender}_{i}\beta_{6}+ \mbox{alc_mod}_{i}\beta_{7} + \\ &  \mbox{alc_heavy}_{i}\beta_{8} \mbox{bcs}_{i}\mbox{gender}_{i}\beta_{9} + \mbox{pindex}_{i}\mbox{gender}_{i}\beta_{10} + \mbox{enzyme}_{i}\mbox{gender}_{i}\beta_{11} + \mbox{liver}_{i}\mbox{gender}_{i}\beta_{12}  + \\ & \mbox{age}_{i}\mbox{gender}_{i}\beta_{13} + \mbox{bcs}_{i}\mbox{alc_mod}_{i}\beta_{14} + \mbox{pindex}_{i}\mbox{alc_mod}_{i}\beta_{15} + \mbox{enzyme}_{i}\mbox{alc_mod}_{i}\beta_{16} +  \\ & \mbox{liver}_{i}\mbox{alc_mod}_{i}\beta_{17} + \mbox{age}_{i}\mbox{alc_mod}_{i}\beta_{18} + \mbox{bcs}_{i}\mbox{alc_heavy}_{i}\beta_{19} + \mbox{pindex}_{i}\mbox{alc_heavy}_{i}\beta_{20} + \\ & \mbox{enzyme}_{i}\mbox{alc_heavy}_{i}\beta_{21} + \mbox{liver}_{i}\mbox{alc_heavy}_{i}\beta_{22} + \mbox{age}_{i}\mbox{alc_heavy}_{i}\beta_{23} + \varepsilon_{i}.
\end{split}
\nonumber
\end{equation}
En este caso tenemos $2^{23}=8'388,608$ posibles modelos. Lo que hace que sea difícil ajustarlos todos (aunque es posible usando la librería ``leaps``). Por lo tanto, vamos a utilizar los algortimos de selección.

**Selección hacia delante**. Podemos utilizar la función ``ols_step_forward_aic`` de la librería ``olsrr``:

```{r surgicalForward, echo=T, warning=FALSE,message = FALSE}
mod.surgical.completo2 = lm(log(y)~bcs*gender+pindex*gender+enzyme_test*gender+liver_test*gender+age*gender+ bcs*alc_mod+pindex*alc_mod+enzyme_test*alc_mod+liver_test*alc_mod+age*alc_mod+bcs*alc_heavy+pindex*alc_heavy+enzyme_test*alc_heavy+liver_test*alc_heavy+age*alc_heavy,data=surgical)
res =ols_step_forward_aic(mod.surgical.completo2,details = F)
```
Con el argumento ``details = T`` se puede ver la selección con más detalle. Usando este algoritmo el modelo óptimo es:
\begin{equation}
\begin{split}
\log y_{i} =& \beta_{0} + \mbox{bcs}_{i}\beta_{1} + \mbox{pindex}_{i}\beta_{2} + \mbox{enzyme}_{i}\beta_{3} + \mbox{age}_{i}\beta_{4} + \mbox{gender}_{i}\beta_{5} + \\
&\mbox{gender}_{i}\mbox{pindex}_{i}\beta_{6} + \mbox{gender}_{i}\mbox{enzyme}_{i}\beta_{7} + \mbox{bcs}_{i}\mbox{alc_heavy}_{i}\beta_{8} + \varepsilon_{i}.
\end{split}
\nonumber
\end{equation}

**Selección hacia atrás**. Podemos utilizar la función ``ols_step_backward_aic`` de la librería ``olsrr``:

```{r surgicalBackward, echo=T, warning=FALSE,message = FALSE}
ols_step_backward_aic(mod.surgical.completo2,details = F)
```
Por lo tanto, el modelo seleccionado es:
\begin{equation}
\begin{split}
\log y_{i} =& \beta_{0} + \mbox{bcs}_{i}\beta_{1} + \mbox{pindex}_{i}\beta_{2} + \mbox{enzyme}_{i}\beta_{3} + \mbox{gender}_{i}\beta_{4} + \mbox{liver}_{i}\beta_{5} + \\
& \mbox{gender}_{i}\mbox{enzyme}_{i}\beta_{6} + \mbox{enzyme}_{i}\mbox{alc_mod}_{i}\beta_{7} + \mbox{liver}_{i}\mbox{alc_mod}_{i}\beta_{8} + \mbox{liver}_{i}\mbox{gender}_{i}\beta_{9} \varepsilon_{i}.
\end{split}
\nonumber
\end{equation}
Con este algoritmo no se considera la edad del paciente pero si la función hepática y otras interacciones.

**Selección por segmentos**. Aquí tenemos la función ``ols_step_both_aic`` de la librería ``olsrr``:

```{r surgicalBoth, echo=T, warning=FALSE,message = FALSE}
ols_step_both_aic(mod.surgical.completo2,details = F)
```
Note que este método sigue los mismos pasos que la selección hacia delante hasta el paso 8 donde se elimina la interacción entre el índice de pronostico y el genero. Por lo que aquí obtenemos el siguiente modelo:

\begin{equation}
\begin{split}
\log y_{i} =& \beta_{0} + \mbox{bcs}_{i}\beta_{1} + \mbox{pindex}_{i}\beta_{2} + \mbox{enzyme}_{i}\beta_{3} + \mbox{age}_{i}\beta_{4} + \mbox{gender}_{i}\beta_{5} + \\
& \mbox{gender}_{i}\mbox{enzyme}_{i}\beta_{6} + \mbox{bcs}_{i}\mbox{alc_heavy}_{i}\beta_{7} + \varepsilon_{i}.
\end{split}
\nonumber
\end{equation}

Dado que los algoritmos hacen la busqueda del modelo ``óptimo'' evaluando diferentes subconjuntos de covariables, se obtuvieron diferentes ajustes. Si observamos el AIC de las tres opciones, el modelo obtenido con el algoritmo stepwise presenta el mejor resultado.

### Regresión de LASSO
El estimador LASSO (Least Absolute Selection and Shrinkage
Operator) minimiza la siguiente expresión:

\begin{equation}
\begin{split}
S_{lasso}(\beta)=& \sum_{i=1}^{n}(y_{i}-x_{i}^{′}\beta)^{2}+
\lambda\sum_{j=1}^{p-1}|\beta_{j}|                            
\end{split}
\nonumber
\end{equation}

La penalización sobre $\sum_{j=1}^{p-1}|\beta_{j}|$ tiene como efecto forzar a que los
coeficientes tiendan a cero.

A medida que \lambda se incrementa, mayor es la penalización y más
coeficientes tomarán el valor de cero (excluimos covariables que no
son relevantes).

Al igual que en la regresión ridge, se recomienda escalar las
covariables

#### Métodos de regularización
De forma de equivalente, $\hatbbeta_{LASSO}$ minimiza:

\[
\sum_{i=1}^{n}(y_{i}-x_{i}^{′}\beta)^{2} \quad \mbox{ sujeto a } \quad
\sum_{j=1}^{p-1}|\beta_{j}\leq t.
\]

Mientras que, en la regresión de ridge,$\hatbbeta_{ridge}$ minimiza:

\[
\sum_{i=1}^{n}(y_{i}-x_{i}^{′}\beta)^{2} \quad \mbox{ sujeto a } \quad
\sum_{j=1}^{p-1}\beta_{j}^2\leq t.
\]

Cuando $\lambda \rightarrow 0$ , entonces $\hatbbeta_{LASSO} \rightarrow \hatbbeta$, y cuando 
$\lambda \rightarrow \infty$, entonces $\hatbbeta_{LASSO} \rightarrow 0$.

También, cuando $\lambda \rightarrow \infty$, la varianza de $\hatbbeta_{LASSO}$ disminuye, pero el sesgo aumenta.

No hay una estimación analítica para $\hatbbeta_{LASSO}$, pero hay algoritmos
eficientes para su estimación.

```{r Vgrasalasso, echo=T, warning=FALSE,message = FALSE, fig.align = "center", fig.cap="Estimación de los coeficientes vs log(lambda)"}
#se debe especificar alpha=1
X = model.matrix(mod.fat)[,-1]
lasso.mod <- glmnet(X, fat$brozek, alpha = 1,nlambda = 100)
plot(lasso.mod,xvar='lambda',label=T,lwd=2)
abline(h=0,lty=2)
```


#### Validación cruzada

La validación cruzada se utiliza para evaluar y comparar modelos.

Consiste en dividir la muestra en dos grupos:

- **Entrenamiento:** se usa para ajusta el modelo.
- **Validación:** se utiliza para validar el modelo.

Para no perder información, en la validación cruzada se divide la
muestra en dos (o más) partes y se hace la validación en cada una.

División de la muestra de forma aleatoria en $k = 5$ grupos $(k-fold)$

```{r ssa-logo, fig.align = 'center',out.width = "75%",echo=FALSE}
knitr::include_graphics(here::here("figs", "ValidacionCruzada.png"))
```
Para cada división,$k = 1, . . . , K$ , y para cada valor de $\lambda$, se estima
el modelo basado en la **muestra de entrenamiento**.

Mientras que con cada **muestra de validación**, y para cada valor de
$\lambda$, se utiliza para calcular el error cuadrático medio:

\[
EMC_{k}(\lambda) = \sum_{i=1}^{n_k} \frac{[y_{i}^{(k)}-x_{i}^{(k)}\hatbbeta_{lasso}^{(k)}(\lambda)]^2}{n}               
\]

donde $y_{i}^{(k)}$ son las observaciones de la muestra de validación $k$, y $\hatbbeta_{lasso}^{(k)}(\lambda)$ es la estimación utilizando la muestra de entrenamiento $k$.

Para cada $\lambda$, se calcula la validación cruzada como:


\[
CV(\lambda) = \frac{1}{K}\sum_{i=1}^{K}EMC_{k}(\lambda)              
\]
y la desviación estándar:

\[
SD(\lambda) = \sqrt{\sum_{i=1}^{K} \frac{[EMC_{k}(\lambda)-CV(\lambda)]^2}{K-1}}              
\]
Luego, selección el $\lambda$ que minimiza $CV(\lambda)$:
\[
\hat{\lambda}_{cv}=arg\quad mín_{\lambda}-CV(\lambda)
\]

También, se puede aplicar la regla de una desviación estánda:

\[
\hat{\lambda}_{cv1sd}=máx \{\lambda:CV(\hat{\lambda})<CV(\hat{\lambda}_{cv})+SD(\hat{\lambda}_{cv})\}
\]

#### Ejemplo grasa corporal
Validación cruzada con $k=10$.
```{r kgrasa, echo=T, warning=FALSE,message = FALSE, fig.cap="Validación cruzada grasa corporal"}
lasso.cv <-cv.glmnet(X, fat$brozek, nfolds = 252, alpha = 1,nlambda = 100)
plot(lasso.cv)
```
Las covariables seleccionadas al estimar el lambda óptimo (regla una desviación estándar):
```{r}
est = glmnet(X, fat$brozek, alpha = 1,lambda = lasso.cv$lambda.1se)
est$beta
```

Observamos que las variables seleccionadas son ```age```, ```height```,```abdom``` y ```wrist```:

````{r}
mod.lasso = lm(brozek ~ age+height+abdom+wrist,data=fat)
summary(mod.lasso)
```` 
Las covariables selecionas en este modelo son todas significativas, el $R^2=0.7223$ y el $R^2_{adj}=0.7178$ han disminuido ligeramente respecto al modelo con todas las covariables.

```{r, echo=FALSE, include=TRUE, results="asis"}

mathy.df <- data.frame(b0=c("int.","age","weight","height","neck",
     "abdom","hip","thigh","forearm","wrist"), 
b1=c(-20.062,0.059,-0.084,"-",-0.432,0.877,-0.186,0.286,0.4825,-1.4049),
b2=c(10.8465,0.0285,0.0370,"-",0.2080,0.0666,0.1282,0.1195,0.1725,0.4717),
b3=c(0.0656, 0.0388,0.0237,"-", 0.0389, 0.0000, 0.1473, 0.1473, 0.0056, 0.0032),
b4=c(-31.297,"-",0.126,"-","-",0.921,"-","-",0.446,-1.392),
b5=c( 6.7089,"-",0.0229,"-","-",0.0519,"-","-",0.1682,0.4099),
b6=c(0.0000,"-",0.0000,"-","-",0.0000,"-","-",0.0085,0.0008),
b7=c(0.249,0.067,"-",-0.165,"-",0.676,"-","-","-",-1.937),
b8=c(6.2785, 0.0220,"-", 0.0782,"-",0.0312,"-","-","-",0.3834),
b9=c( 0.9685,0.0025,"-",0.0363,"-",0.0000,"-","-","-",0.0000)
)
colnames(mathy.df)<-c("","Est"," er. std.","valor-p","Est"," er. std.","valor-p","Est"," er. std.","valor-p")
kable(mathy.df, escape=FALSE,format = "html", booktabs = T)%>% kable_styling(bootstrap_options = "striped",full_width = F)%>%
  add_header_above(c("","AIC y PRESS" = 3,"BIC"=3,"LASSO"=3))%>%
  add_header_above(c("Método de selección" = 10))

```

```{r, echo=FALSE, include=TRUE, results="asis"}
mathy.df <- data.frame(b0=c("AIC y PRESS","BIC","LASSO"),
                       b1=c( 0.7467, 0.7351, 0.7223),
                       b2=c( 4139.682, 4209.14, 4447.052),
                       b3=c(1420.225,1423.471,1435.389),
                       b4=c(1455.52,1444.647,1456.566)
                       )

colnames(mathy.df)<-c("Modelo","$R^2$","PRESS","AIC","BIC")
kable(mathy.df, escape=FALSE,format = "html", booktabs = T)%>% kable_styling(bootstrap_options = "striped",full_width = F)
```






<!--chapter:end:04-SeleccionVariables.Rmd-->

# Modelos no lineales
```{r preamble5, include=FALSE}
library(alr4)
library(nlstools)
library(car)
data(turk0)
data(Puromycin)
```
## Ejemplos
### Crecimiento de pavos
Datos: ```turk0``` de la librería ```alr4```

Objetivo: evaluar la metionina como suplemento alimenticio para
pavos.

Se alimentó a 60 corrales de pavos con una dieta similar,
complementada con una dosis de metionina diferente. Luego de un
tiempo, se observó el peso ganado por corral.

Las variables son:

- **```A```:** Cantidad de suplemento de metionina ( % de la dieta).
- **```Gain```:**  Peso medio ganado por corral (gramos) después de 3 semanas.

```{r plotpavos, include=TRUE,fig.cap ="Nube de puntos"}
plot(Gain~A,data=turk0,xlab='cantidad de metionina (% dieta)',ylab='Peso ganado (gramos)')

```
Para estos datos se puede proponer el siguiente modelo:
\[
E(Gain|A)=\theta_{1}+\theta_{2}[1-exp(-\theta_{3}A)]
\]

- Si $A=0$, entonces $E(Gain|A)=\theta_{1}$ (peso ganado sin suplemento).
- Si $\theta_{3}>0$, $\theta_{1}+\theta_{2}$ es la asíntota (máximo peso que se puede
ganar).
- $\theta_{2}$ es el máximo crecimiento adicional debido al suplemento.
- $\theta_{3}$ representa la tasa de crecimiento. A valores de θ3 mas
grandes, el crecimiento esperado se acerca a su máximo más
rápidamente.

### Puromicina
Datos: ```Puromycin.```
Objetivo: evaluar la velocidad de una reacción enzimática de células
tratadas con Puromicina.

Se midió la reacción enzimática (qué tan rápido ésta cataliza la reacción que 
convierte un sustrato en producto) de 23 encimas (12 tratadas con Puromicina).

Las variables son:

- ```conc``` :concentración de sustrato (ppm).
- ```rate```:velocidad de reacción instantáneas (conteo/min2)
- ```state```:tratado y no tratado.

```{r plotpurom, include=TRUE, fig.cap = "Encimas tratadas (puntos negros) - Encimas no tratadas (puntos rojos)"}
plot(Puromycin$conc,Puromycin$rate,col=Puromycin$state,
     xlab='concentración de sustrato (ppm)',
     ylab='velocidad de reacción')
```
Encimas tratadas (puntos negros) - Encimas no tratadas (puntos rojos)

Modelo Michaelis-Menten (bioquímica):

\[
y_{i}=\frac{x_{1}\theta_{1}}{\theta_{2}+x_{1}}+\epsilon_{i}.
\]
"falta insertar grafica"

Por lo que para estos datos se puede proponer el modelo:

\[
rate_{i}=\frac{conc_{i}\theta_{1}+state_{i}conc_{i}\theta_{3}}
{\theta_{2}+state_{i}\theta_{3}+conc_{i}}+\epsilon_{i}.
\]

Por lo que se tiene una curva diferente para las enzimas tratadas y
no tratadas:

- Para enzimas no tratadas:

\[
E(rate_{i}|state=0)=\frac{conc_{i}\theta_{1}}{\theta_{2}+conc_{i}}.
\]

-Para enzimas tratadas:
\[
E(rate_{i}|state=1)=\frac{conc_{i}(\theta_{1}+\theta_{3})}{(\theta_{2}+\theta_{4})+conc_{i}}.
\]

## Modelos no lineales
En modelos de regresión asumimos que:

\[
y_{i}=m(x_{i},\theta)+\epsilon_{i}.
\]

En el caso de **modelos lineales:**
\[
m(x_{i},\theta)=\Psi_{j}(x_{i},\psi)^{'}\beta.
\]

donde $\Psi(\cdot)$ es una función de unos parámetros constantes $\psi$
(es decir, puedo asumir transformaciones sobre las covariables).
$\Psi_{j}(x_{i},\psi)=x_{i}$, tenemos:

\[
m(x_{i},\theta)=\beta_{0}+x_{1i}\beta_{1}+x_{2i}\beta_{2}+...+x_{p-1,i}\beta_{p-1}.
\]

Los modelos:
\[
y_{i}=m(x_{i},\theta)+\epsilon_{i}=\theta_{1}+\theta_{1}[1+exp(-\theta_{4}x_{i})]+\epsilon_{i},
\]
y

\[
y_{i}=m(x_{i},\theta)+\epsilon_{i}=\frac{x_{i}\theta_{i}}{\theta_{2}+x_{i}}+\epsilon_{i},
\]

son modelo no-lineal (no es una combinación lineal de los
parámetros).

Si hacen los mismos supuestos sobre los errores, esto es:
\[
\epsilon\sim N(\bZERO,\sigma^2 \bI)
\]

se tiene que:

- $E(y|x_{i})=m(\bx_{i},\btheta)$
- $E(y|x_{i})=\sigma^2$

## Modelos no-lineales linealizables    
Modelo de regresión exponencial:
\[
E(y)=\theta_{0}+\theta_{1}exp(\theta_{2}+x_{i}\theta_{3})
\]

Si $\theta_{0}=0$, el modelo es linealizable:
\[
logy_{i}=(log\theta_{1}+\theta_{2})+x_{i}\theta_{3}+\epsilon_{i}^*
\]
Sin embargo, hay que tener cuidado con el efecto de las
transformaciones sobre los residuos.

### Estimación de los parámetros

La estimación de $\btheta$ se hace minimizando la suma de cuadrados de
los residuos:

\[
S(\btheta)=\sum_{i=1}^n[y_{i}-m(\bx_{i},\btheta)]^2
\]

Para encontrar el mínimo, $(1)$ calculamos la derivada de $S(\btheta)$ con respecto a $\btheta$:

\[
\frac{\partial S(\btheta)}{\partial\btheta}=-2\sum_{i=1}^n[y_{i}-m(\bx_{i},\btheta)][\frac{\partial m(\bx_{i},\btheta)}{\partial\btheta}]
\]

$(2)$ igualamos a $0$, y $(3)$ resolvemos la ecuación para $\btheta$.

En la mayoría de los casos, $\frac{\partial S(\btheta)}{\partial\btheta}$ es una función no-lineal $\btheta$.

Por lo tanto, no es posible encontrar una solución analítica y
necesitamos encontrar la solución **iterativamente**.


"insertar grafico 12.1"

### Notación

- $\theta_{j}^{(t)}$: estimación de $\theta_{j}$ en la iteración $t$ ($\theta_{j}^{(0)}$ valores iniciales).

- Vector score (gradiente):


$$
u(\btheta)=\frac{\partial S(\btheta)}{\partial\btheta}=\begin{pmatrix} 
\frac{\partial S(\btheta)}{\partial\btheta} \\ 
\frac{\partial S(\btheta)}{\partial\btheta} \\
\vdots \\
\frac{\partial S(\btheta)}{\partial\btheta} \\
\end{pmatrix}
\quad
u(\hat{\btheta})=u(\btheta)|_{\btheta=\hat{\btheta}}
$$

- Matriz Hessiana (Jacobiano):

$$
\bH(\btheta)=  \frac{\partial^2 S(\btheta)}{\partial\btheta^{'} \partial\btheta}=\begin{pmatrix} \frac{\partial^2 S(\btheta)}{\partial^2 \btheta_{1}} & \frac{\partial^2 S(\btheta)}{\partial \btheta_{1} \partial \btheta_{2} } & \dots & \frac{\partial^2 S(\btheta)}{\partial \btheta_{1} \partial \btheta_{p}} \\
\frac{\partial^2 S(\btheta)}{\partial \btheta_{2} \partial \btheta_{1}} & \frac{\partial^2 S(\btheta)}{\partial^2 \btheta_{2}} & \dots & \frac{\partial^2 S(\btheta)}{\partial \btheta_{2} \partial \btheta_{p}}\\
\vdots & \vdots & \ddots & \vdots \\
\frac{\partial^2 S(\btheta)}{\partial \btheta_{p} \partial \btheta_{1}} & \frac{\partial^2 S(\btheta)}{\partial \btheta_{p} \partial \btheta_{2}} & \dots & \frac{\partial^2 S(\btheta)}{\partial^2 \btheta_{p}}
\end{pmatrix} \quad \quad \quad \bH(\hat{\btheta})=\bH(\btheta)|_{\btheta=\hat{\btheta}}
$$

### Expansión de series de Tylor

Una función $f(\theta)$ puede expandirse como una serie de Taylor:

$$
f(\theta)=\sum_{n=0}^\infty \frac{1}{n!}(\theta-\theta^*)^n \frac{\partial^nf(\theta^*)}{\partial\theta^n}
$$

Una aproximación de la función $f(\theta)$ en los valores alrededor del punto $\theta^*$ se puede hacer usando la series de Taylor con solo las dos primeras
derivadas (orden 2):

$$
f(\theta)\approx f(\theta^*)+(\theta-\theta^*) \frac{\partial f(\theta^*)}{\partial\theta}+\frac{1}{2}(\theta-\theta^*)^2\frac{\partial^2 f(\theta^*)}{\partial\theta^2}
$$

En caso de $\btheta$ (vector), entonces:

$$
f(\btheta)\approx f(\btheta^*)+(\btheta-\btheta^*)^{'}u(\btheta^*)+\frac{1}{2}(\btheta-\btheta^*)^{'}H(\btheta^*)(\btheta-\btheta^*),
$$

### Métodos iterativos de estimación
Algunos métodos iterativos de estimación son:

- Gauss-Newton (approx. series de Taylor a la función de la
media).

-Newton-Raphson (approx. series de Taylor a la función score).

#### Algoritmo de Gauss-Newton
La idea es aproximar $m(x_{i},\btheta^*)$ usando series de Taylor de orden 1 alrededor de $\btheta^*$:

$$
m(x_{i},\btheta)\approx m(x_{i},\btheta^*)+(\btheta-\btheta^*)^{'}u_{i}(\btheta^*)
$$

Lo que lleva a una aproximación de la suma de cuadrados de los residuos:

\begin{equation}
\begin{split}
S(\btheta)&=\sum_{i=1}^n[y_{i}-m(x_{i},\btheta)]^2 \approx \sum_{i=1}^n[y_{i}-m(x_{i},\btheta^*)+(\btheta-\btheta^*)^{'}u_{i}(\btheta^*)]^2 \\
&= \sum_{i=1}^n[\hat e_{i}^*+(\btheta-\btheta^*)^{'}u_{i}(\btheta^*)]^2,
\end{split}
\end{equation}

Esta aproximación de $S(\btheta)$ es equivalente a una suma de cuadrados de un modelo lineal con $\hat e_{i}^*$ (residuos de trabajo) como variable respuesta y $u_{i}(\btheta^*)$ como covariables.

Por lo tanto, la solución es:


$$
(\hat{\btheta}-\btheta^*)=[U(\btheta^*)^{'}U(\btheta^*)]^{-1}
  U(\btheta^*)^{'} \hat{e_{i}^*}
$$

\begin{equation}
\hat{\btheta}=\btheta^*+[U(\btheta^*)^{'}U(\btheta^*)]^{-1}U(\btheta^*)^{'} \hat{e_{i}^*}
(\#eq:AlgorGN)
\end{equation}

donde:

- $\hat{e_{i}^*}=(\hat{e_{1}^*},...,\hat{e_{n}^*})^{'}$

- $U(\btheta^*)$ es una matriz con la fila $i$ igual a $u_{i}(\btheta^*)$.

A partir de estas ecuaciones se propone el **algoritmo de
Gauss-Newton**.

1. Seleccione unos valores iniciales $\btheta_{0}$  y calcule $S(\btheta_{0})$.
2. Establezca el contador de iteraciones en $k=0$
3. Calcule $U(\btheta^{(j)})$ y $\hat{e}^{(j)}$ y encuentre $\btheta^{(j+1)}$ usando \@ref(eq:AlgorGN):

\begin{equation}
\begin{split}
& \btheta^{(j+1)}=\btheta^{(j)}+[U(\btheta^{(j)})^{'}U(\btheta^{(j)})]^{-1}U(\btheta^{(j)})^{'} \hat{e}^{(j)} \\
& \text{y calcule} \quad S(\btheta^{(j+1)}).
\end{split}
\end{equation}
   

4. Pare si $\delta=|S(\btheta^{(j)})-S(\btheta^{(j+1)})|$ es suficientemente pequeño (convergente). De otra forma, $j=j+1$ y vaya al paso 3.

Si $j$ es muy grande (muchas iteraciones), se dice que hay divergencia.

El algoritmo de Gauss-Newton estima los parámetros de un problema
de regresión no lineal mediante una secuencia de cálculos de mínimos cuadrados lineales aproximados.

La estimación de $\sigma^2$ es:

$$
\hat{\sigma}^2=\frac{1}{n-p}\sum_{i=1}^n[y_{i}-m(x_{i},\hat{\btheta)}]^2,
$$

donde $p$ es la dimensión de $\btheta$.

### Estimación de los parámetros

**¿Cómo selecciono los valores iniciales?**

El ajuste de un modelo no-lineal requiere buenos valores iniciales
(cercanos a los valores de parámetros).

los valores iniciales se pueden obtener a través:

- Conocimiento previo.

- Significado físico de los coecientes.

- Evaluación gráfica.

- Linearización de los datos.

Dado que la solución del algoritmo puede caer en un máximo local, es recomendable ejecutar el algoritmo para diferentes valores iniciales.

#### Crecimiento de pavos - Valores iniciales

En el caso del peso de los pavos:

- $\theta_{1}^0=620$ (pesi ganado sin suplemento)

- $\theta_{2}^0+\theta_{1}^0=800$ (Asíntota). Por lo tanto $\theta_{2}^0=180$ 

- $\theta_{3}^0$ se puede obtener a partir de resolver la ecuación para un punto posible:

$$
750=620+180[1-exp(-\theta_{3}^00.16)]
$$

Resolviendo la ecuación $\theta_{3}^0\approx8$.

```{r plotpavoscrec, echo=T, include=T,fig.align = "center", fig.cap = "Datos crecimiento de pavos. Ajuste del modelo para el peso medio ganado por corral en función de la cantidad de suplemento de metionina.",warning=FALSE,message = FALSE}

mod = nls(Gain ~ th1 + th2*(1-exp(-th3*A)),data = turk0,
          start = list(th1=620,th2=180,th3=8),trace=F)

plot(Gain~A,data=turk0,xlab='cantidad de metionina (% dieta)',ylab='Peso ganado (gramos)')

th = coef(mod)
x = seq(0,0.5,length.out=100)
lines(x, th[1]+th[2]*(1-exp(-th[3]*x)),col=2, lwd = 2)
```
$$
E(Gain|A)=622.958 + 178.252 [1 - exp(-7.122A)]    
$$

#### Inferencia sobre los parámetros

si $\epsilon \sim N(\bZERO,\sigma^2 \bI)$, tenemos que asintóticamente $(n \to \infty)$:

$$
\hat{\btheta}\sim N(\btheta^*,\sigma^2[U(\btheta^*)U(\btheta^*)^{'}]^{-1}).
$$

Dado que automáticamente $\btheta^* \to \btheta$, $\hat{\btheta}$  es un estimador insesgado
de $\btheta$.

Hay que hacer énfasis que estas son propiedades para muestras
grandes, para muestras pequeñas, estas propiedades pueden ser
inadecuadas.

A partir de las propiedades de muestras grandes se pueden hacer
inferencias sobre los coeficientes $\btheta$. Por ejemplo:

**Pruebas de hipótesis:** $\qquad H_{0}:\theta_{j}=\theta_{0}, \qquad H_{1}:\theta_{j}\ne\theta_{0}$

$$
t_{0}:\frac{\hat{\theta_{j}}-\theta_{0}}{\sqrt{V(\hat{\theta_{j}})}}, \quad \text{donde} \quad t_{0} \sim t_{n-p}
$$
**Intervalos de confianza:**IC del $(1-\alpha)$% para $\theta_{j}$:

$$
\hat{\theta_{j}}\pm t_{|1-\alpha/2,n-p}\sqrt{V(\hat{\theta_{j}})} 
$$

**Intervalos de confianza:** IC del $(1-\alpha)$% para $E(Y|x_{0})$:

Sea $\btheta=(\btheta_{1}^{'},\btheta_{2}^{'})^{'}.$

Hipótesis:
$$
H_{0}:\btheta_{2}=\bZERO \qquad H_{1}:\btheta_{2}\ne\bZERO 
$$

Estadístico de prueba:

$$
F_{0}=\frac{[SS_{res}(\btheta)-SS_{res}(\btheta_{1})]/r}{MS_{res}(\btheta)}\sim F_{r,n-p}.
$$

#### Crecimiento de pavos-Estimación
Modelo estimado:

```{r tablapavos,include=TRUE}
summary(mod)

```

Es posible considerar otros modelos de crecimiento. Por ejemplo:

- Modelo 2 (modelo logístico):

$$
y_{i}=\frac{\theta_{1}}{1+\theta_{2}exp(-\theta_{3}x_{i})}+\epsilon_{i}
$$

- Modelo 3 modelo Weibull:

$$
y_{i}=\theta_{1}+\theta_{2}[1-exp(-\theta_{3}x_{i}^{\theta_{4}})]+\epsilon_{i}
$$

La comparación se puede hacer por criterios de información (AIC o
BIC)

```{r tresmodelospavos, include=TRUE}

plot(Gain~A,data=turk0,xlab='cantidad de metionina (% dieta)',ylab='Peso ganado (gramos)')

mod2 = nls(Gain ~ th1/(1+th2*exp(-th3*A)),data = turk0,
           start = list(th1=620,th2=0.25,th3=8) )

mod3 = nls(Gain ~ th1 + th2*(1-exp(-th3*A^th4)),data = turk0,
           start = list(th1=800,th2=180,th3=8,th4=1) )
           
th2 = coef(mod2)         
th3 = coef(mod3)
lines(x, th[1]+th[2]*(1-exp(-th[3]*x)),col=2, lwd = 2)
lines(x, th2[1]/(1+th2[2]*exp(-th2[3]*x)),col=3, lwd = 2)
lines(x, th3[1]+th3[2]*(1-exp(-th3[3]*x^th3[4])),col=4, lwd = 2)

AIC(mod)
AIC(mod2)
AIC(mod3)

```

#### Puromicina-Estimación

Los valores iniciales del modelo Michaelis-Menten se puede hacer por linealización.

```{r linealpuromicina, include=TRUE} 
par(mfrow=c(1,2))
plot(Puromycin$conc,Puromycin$rate,col=Puromycin$state, xlab='concentración de sustrato (ppm)', ylab='velocidad de reacción')


plot(1/Puromycin$conc,1/Puromycin$rate,col=Puromycin$state, xlab='concentración de sustrato (ppm)', ylab='velocidad de reacción')
```

A través del ajuste por MCO:

$$
\frac{1}{y_{i}}=\beta_{0}+\frac{1}{conc_{i}\beta_{1}}+\epsilon_{i}
$$

Se puede obtener valores iniciales.

Luego de ajustar el modelo:

$$
\theta_{1}^{(0)}=\frac{1}{\hat{\beta}_{0}}=167.408 \qquad \theta_{2}^{(0)}=\frac{\hat{\beta}_{1}}{\hat{\beta}_{0}}=0.039
$$

Inicialmente, se podría asumir $\beta_{3}=\beta_{4}=0.$

Modelo estimado:

```{r tablapuromicina, include=TRUE}

Puromycin$state2 = as.double(Puromycin$state == 'treated')
mod.puromicyn = nls(rate ~ (th1*conc + th3*conc*state2)/(th2+th4*state2+conc),data = Puromycin,
          start = list(th1=168,th2=0.4,th3=0,th4=0),trace=F )
summary(mod.puromicyn )

```

- La tasa de crecimiento máxima es diferente si la enzima es
tratada o no.


- El punto donde se logra la mitad del máximo es el mismo.

```{r puromicinaplotl, include=TRUE}
x = seq(0,1.5,length.out=200)
thP= coef(mod.puromicyn)
plot(Puromycin$conc,Puromycin$rate,col=Puromycin$state,
     xlab='concentración de sustrato (ppm)',
     ylab='velocidad de reacción')

lines(x, thP[1]*x/(thP[2]+x),col=2)
lines(x, (thP[1]+thP[3])*x/(thP[2]+thP[4]+x))

```

### Método de Bootstrap

Las inferencias basadas para muestras grande pueden ser inexactas
y/o engañosas en muestras pequeñas.

En esos casos, se puede hacer inferencias usando remuestreo
(bootstrap).

El bootstrap es una técnica para calcular intervalos de confianza
and pruebas de hipótesis cuando el cumplimiento de los supuestos
asumidos están en duda.

Se quiere calcular un intervalo de confianza para la mediana (o
cualquier otro parámetro) de $Y$. Para esto tomamos una muestra
independiente $\by=(y_{1},...,y_{n})$.

Pasos del boostrap:

1. Obtener una muestra aleatoria con remuestreo de $\by:\by=(y_{1}^{*},...,y_{n}^{*})$.
2. Calcular la mediana usando la muestra el paso 1 $(Me_{1})$.
3. Repita los pasos 1 y 2 un número grande de veces $(B)$.
4. un intervalo de confianza del 95% basado en percentiles muestrales 2.5% y 97.5 %.

#### Bootstrap en regresión

Método residual resampling:

1. Con la muestra dada: $(x_{i},y_{i}),i=1,...,n$ ajustar el modelo y obtener los resifuos: $e_{i}=y_{i}-x_{i}^{'}\hat{\beta}.$

2. Obtener una muestra aleatoria con reemplazo de los residuos $e^*=(e_{1}^*,...,e_{n}^*)$.

3.Crear una variable respuesta bootstrap con $y_{i}^*=x_{i}^{'}\hat{\beta}+e_{1}^*$ y estimar $\hat{\beta}^*$. 

4. Repetir los pasos 1-3 un número grande de veces $(B)$ y obtener
el intervalo de confianza para $\beta_{j}$ usando los percentiles*.

$*$Hay muchas modificaciones y extensiones para calcular los intervalos de confianza.

```{r bootpuro}
set.seed(310)
mod.boot = Boot(mod.puromicyn,method='residual',R=1000)

```
```{r bootgraf, include=TRUE}
pairs(mod.boot$t,labels=c(expression(hat(theta)[1]),expression(hat(theta)[2]),expression(hat(theta)[3]),
                          expression(hat(theta)[4])))
```
**Estimaciones por bootstrap** 
Linea roja: estimación por mínimos
cuadrados. Lineas rojas: percentil 2.5, media y percentil 97.5.

```{r bootgrafconf, include=TRUE}
par(mfrow=c(1,4))
hist(mod.boot$t[,1],breaks = 20,xlab=expression(hat(theta)[1]),main = '')
abline(v=coef(mod.puromicyn)[1],lty=2,lwd=2)
abline(v=mean(mod.boot$t[,1]),lty=2,lwd=2,col=2)
abline(v=quantile(mod.boot$t[,1],c(0.025,0.975),na.rm = T),lty=2,lwd=2,col=2)

hist(mod.boot$t[,2],breaks = 20,xlab=expression(hat(theta)[2]),main = '')
abline(v=coef(mod.puromicyn)[2],lty=2,lwd=2)
abline(v=mean(mod.boot$t[,2]),lty=2,lwd=2,col=2)
abline(v=quantile(mod.boot$t[,2],c(0.025,0.975),na.rm = T),lty=2,lwd=2,col=2)

hist(mod.boot$t[,3],breaks = 20,xlab=expression(theta[3]),main = '')
abline(v=coef(mod.puromicyn)[3],lty=2,lwd=2)
abline(v=mean(mod.boot$t[,3]),lty=2,lwd=2,col=2)
abline(v=quantile(mod.boot$t[,3],c(0.025,0.975),na.rm = T),lty=2,lwd=2,col=2)

hist(mod.boot$t[,4],breaks = 20,xlab=expression(theta[4]),main = '')
abline(v=coef(mod.puromicyn)[4],lty=2,lwd=2)
abline(v=mean(mod.boot$t[,4]),lty=2,lwd=2,col=2)
abline(v=quantile(mod.boot$t[,4],c(0.025,0.975),na.rm = T),lty=2,lwd=2,col=2)

```

Intervalos del 95% de confianza usando bootstrap (corrección de
sesgo):
```{r bootgrafintC, include=TRUE}
quantile(mod.boot$t[,1],c(0.025,0.975),na.rm = T)
quantile(mod.boot$t[,2],c(0.025,0.975),na.rm = T)
quantile(mod.boot$t[,3],c(0.025,0.975),na.rm = T)
quantile(mod.boot$t[,4],c(0.025,0.975),na.rm = T)
```


**Puromicina - bootstrap** \\
Todas las curvas estimadas por bootstrap. Linea roja: estimación puntual.

```{r bootgrafpred, include=TRUE}
fit.rate= function(theta,x){
  cbind(theta[1]*x/(theta[2]+x),
        (theta[1]+theta[3])*x/(theta[2]+theta[4]+x))
}
x= seq(from=0,to=1.1,length.out = 100)

plot(NULL,NULL,xlim=c(0,1.1),ylim=c(0,210),xlab='concentración de sustrato (ppm)',
     ylab='velocidad de reacción')
Fit = mapply(function(i){
  pred = fit.rate(mod.boot$t[i,],x)
  lines(x,pred[,1],col='lightgray')
  lines(x,pred[,2],col='gray')
},i=1:999)
lines(x, thP[1]*x/(thP[2]+x),col=2)
lines(x, (thP[1]+thP[3])*x/(thP[2]+thP[4]+x))
points(Puromycin$conc,Puromycin$rate,col=Puromycin$state)

```

#### Algunas consideraciones

* Lo ideal es que el algoritmo llegue a la solución en pocas
iteraciones (esto pasa si la aproximación lineal es adecuada).

*Siempre es bueno evaluar la solución con diferentes puntos
iniciales. Es posible que caigamos en un máximo local.

*Si el tamaño de muestra no es grande, las propiedades
asintóticas pueden no ser adecuadas. Por lo tanto, es mas
conveniente usar bootstrap para hacer inferencias.









<!--chapter:end:05-ModelosnoLineales.Rmd-->

# Modelo lineal generalizado
## Introducción
```{r preamble6, include=FALSE}
library(faraway)
logdose <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113, 1.8369, 1.8610, 1.8839)
dead <- c(6, 13, 18, 28, 52, 53, 61, 60) # numbers dead
n <- c(59, 60, 62, 56, 63, 59, 62, 60) # binomial sample sizes
Datos=data.frame(logdose,n,dead)
```
### Modelos lineales
Modelo lineal:

$$
y_{i}=\bx_{i}^{'}\bbeta+\epsilon, \quad \text{donde}\quad \epsilon \sim N(\bZERO,\sigma^2\bI)
$$

Lo que implica que $E(y_{i}|\bx_{i})=\bx_{i}\bbeta$ y $V(y_{i}|\bx_{i})=\sigma^2$

En algunos casos es difícil que se cumplan esas propiedades (incluso luego de hacer transformaciones).

Si la variable respuesta $Y$ solo puede tomar dos valores $(y_{i}\in\{0,1\})$ no podríamos representar $E(y|\bx)$ como una función lineal.

Los modelos lineales generalizados (GLM) son una clase de
modelos que permite modelar variables aleatorias con distribución
de probabilidad diferentes a la normal.

### Mortalidad de escarabajos
Número de escarabajos muertos después de cinco horas de
exposición a disulfuro de carbono gaseoso $(CS2mgl^{-1})$ en diversas concentraciones:

```{r TmortEsc, echo=FALSE}
knitr::kable(
  head(Datos[, 1:3], 8), booktabs = TRUE,
  caption = 'Datos mortalidad de escarabajos'
)
```

¿Hay una relación entre la dosis y la mortalidad de escarabajos?

```{r grafMortEsc}
plot(logdose,dead/n,xlab='log dosis',ylab='proporción de muertos',ylim=c(0,1),pch=16)

```

### Modelo logístico

Definiendo $y_{i}=\sum_{i=1}^ny_{ij}/n_{i}$ (la proporción de éxitos en ni ensayos independientes), tenemos que:

$$
n_{i}y_{i}\sim binomial(n_{i},\pi_{i}), \quad i=1,...,n, \quad \text{donde} \quad \pi_{i}=g(\bx_{i},\bbeta).
$$

Entonces: $E(y_{i}|\bx_{i})=\pi_{i}$ y $V(y_{i}|\bx_{i})=\pi_{i}(1-\pi_{i})/n_{i}$.

El modelo ligístico es un GLM y asume que:

$$
\pi_{i}=g^{-1}(\bx_{i},\bbeta)=\frac{exp(\bx_{i}^{'}\bbeta)}{1+exp(\bx_{i}^{'}\bbeta)}=\frac{1}{1+exp(-\bx_{i}^{'}\bbeta)}
$$

Por lo que: $g(\pi_{i})=log(\frac{\pi_{i}}{1-\pi_{i}})=\bx_{i}^{'}\bbeta$ **(función logit).**

```{r logfun, echo=FALSE, fig.align = "center",fig.cap = "Función logística"}
x= seq(from=-8,to=8,length.out = 1000)
curve(1/(1+exp(-x)),-8,8,lwd=2,ylab='y',xlab='log[y/(1-y)]')
abline(h=0,lty=2,lwd=1)
abline(h=1,lty=2,lwd=1)
```
### ataques de epilepsia

Ensayo clínico para evaluar el impacto de progabida sobre las crisis
epilépticas (```data(epilepsy)``` de la librería ```HSAUR2```).

Datos:

* ```age```: edad del paciente.

* ```base```: número de ataques epilépticos (x 8 semanas) antes del
ensayo.

* ```treatment```: tratamiento (placebo, progabida).

* ```seizure.rate```(variable respuesta): número de ataques epilépticos (x dos semanas) luego de 8 semanas.

"insertar graficos de epilepsia"

#### Modelo poisson

Aquí podemos suponer que:

$$
y_{i}\sim Poisson(\lambda_{i}), \quad i=1,...,n,\quad \text{donde} \quad \lambda_{i}=g(\bx_{i},\bbeta).
$$

Entonces:$E(y_{i}|\bx_{i})=V(y_{i}|\bx_{i})=\lambda_{i}).$

El modelo Pooisson es un GLM y asume que:

$$
\lambda_{i}=g^{-1}(\bx_{i},\bbeta)=exp(\bx_{i}^{'}\bbeta).
$$

Por lo que: $g(\lambda_{i}=log\lambda_{i}=\bx_{i}^{'}\bbeta$ **(función log)**.

## Modelo lineal generalizado (GLM)

Un modelo lineal generalizado (GLM) tiene tres componentes:

* **Componente aleatorio:** variable respuesta $Y$ y su distribución de probabilidad.

* **Predictor lineal:**

$$
\eta=\bx^{'}\bbeta,
$$

donde $\bbeta$ es un vector de parámetros y $\bx$ un vector de
covariables.

* **Función de enlace:** una función g que conecta $E(Y)$ con el predictor lineal, 

$$
g[E(Y|\bx)]=\bx^{'}\bbeta
$$

### Componente aleatorio

Observaciones independientes $(y_{i},...,y_{n})$ de una variable aleatoria $Y$ cuya distribución de probabilidad pertenece a la **familia exponencial.** 

Restringir un GLM a la familia exponencial permite tener expresiones generales para:

* La función de verosimilitud y funciones score.

* distribución asintótica de los estimadores de los parámetros del modelo

* Algoritmo para ajustar el modelo.

### Predictor lineal

Para cada observación $i$,

$$
\bx_{i}=(1,x_{i1},...,x_{i(p-1)})^{'},
$$

donde $x_{ij}$ es la observación $i$ de la covariable $j,\quad j=1,...,p-1$.

Predictor lineal es una combinación lineal de las covariables:

$$
\eta_{i}=\beta_{0}+\sum_{j=1}^{p-1}\beta_{j}x_{ij}=\bx_{i}^{'}\bbeta
$$

Un GLM asume que las covariables no son aleatorias.

### Función de enlace

Sea:

$$
E(Y|\bx_{i})=\mu_{i}, \quad i=1,...,n.
$$

En algunas distribuciones,$\mu_{i}$ está acotada en un intervalo. Por ejemplo, en la distribución binomial, $0\leq \pi_{i}\leq 1$, o en la Poisson, $\lambda_{i}>0$.

El GLM conecta $\mu_{i}$ con $\eta_{i}$:

$$
\mu_{i}=g^{-1}(\eta_{i})=g^{-1}(\bx_{i}^{'}\bbeta)
$$

La función $g(\cdot)$ es monótona y diferenciable.

$g(\cdot)$ esta determinada generalmente por la distribución que se asume para $Y$.

### Ejemplos de GLM

Algunos ejemplos de GLM:

|Tipo de respuesta|Distribución|función de enlace|Modelo|
|:----------------|:------------|:--------------|:------|
|Continuo | Normal    | Identidad | Modelo lineal    |
| Binaria | Bernoulli | Logit     | Modelo logístico |
| Conteo  | Poisson   | Log       | Modelo Poisson   |

Otros ejemplos son **beta** , **gamma**, **exponencial**, ...

hay extensiones del GLM para distribuciones:

* **binomial negativa** para conteo con sobredispersión.

* **beta-binomial** para ensayos Bernoulli correlacionados (sobredispersión).

* **multinomial** para variables nominales (ordinales) con más de
dos categorías

* **Weibull** para tiempos de falla.

### Ajuste de un GLM

El proceso de ajustar un GLM incluye:

* **Especificación del modelo**.Definición del componente
aleatorio, predictor lineal y función de enlace.

* **Estimación de los parámetros** del modelo.

* **Evaluación del modelo**. ¿El modelo describe bien los datos?

* **Inferencia**. Intervalos de confianza, pruebas de hipótesis e
interpretación de los resultados.

### Familia exponencial

La distribución de probabilidad de una variable aleatoria Y pertenece
a la **familia exponencial** si la función de densidad (o masa) de Y toma esta forma:

$$
f(y;\theta,\phi)exp\{[y\theta-b(\theta)]/a(\phi)+c(y,\phi)\}
$$

donde:

* $\theta$ es el parámetro natural.
* $\phi>0$ parámetro de dispersión.

Además se tiene que:

$$
E[Y]=b^{'}(\theta) \quad \text{y} \quad V[Y]=b^{''}(\theta)a(\phi).
$$

#### Ejemplo

La distribución Poisson:

$$
f(y;\mu)=\frac{\mu^yexp(-\mu)}{y!}, \quad \theta>0.
$$

se puede re-escribir como:

$$
f(y;\mu)=exp(-\mu+ylog\mu-logy!).
$$

Por lo tanto:

* $\theta=log\mu, \quad b(\theta)=exp(\theta)$.
  
* $a(\phi)=1$ y $c(y,\phi)=-lny!$.

La distribución normal:

$$
f(y;\mu,\sigma^2)=\frac{1}{\sqrt{2\pi\sigma}}exp[-\frac{()}{}]
$$

Se puede re-escribir como:

$$
f(y;\mu,\sigma^2)=exp[\frac{y\mu-\frac{1}{2}\mu^2}{\sigma^2}-\frac{1}{2}log(2\pi\sigma^2)-\frac{y^2}{2\sigma^2}]
$$

donde:

* $\theta=\mu, \quad b(\theta)=\frac{1}{2}\theta^2$.

* $a(\phi)=\sigma^2$ y $c(y,\phi)=-\frac{1}{2}log(2\pi\sigma^2)-\frac{y^2}{2\sigma^2}$.

La distribución binomial:

$$
f(y;\pi)=\left(\begin{array}{c}n\\y\end{array}\right)\pi^y(1-\pi)^{n-y}.
$$

se puede re-escribir como:

$$
f(y;\pi)=exp\{y[log\pi-log(1-\pi)]+nlog(1-\pi)+log\left(\begin{array}{c}n\\y\end{array}\right)\}
$$
donde:

* $\theta=log(\frac{\pi}{1-\pi}), \quad b(\theta)=-nlog[1+exp(\theta)]$. 

* $c(\phi)=1$ y $d(y,\phi)=log\left(\begin{array}{c}n\\y\end{array}\right)$.


  #### Familia exponencial


```{r, echo=FALSE, include=TRUE, results="asis"}
library(knitr)

mathy.df <- data.frame(b4=c("Normal","Binomial", "Poisson"), 
                       b0=c("$\\mu$","$log(\\frac{\\pi}{1-\\pi})$","$log(\\lambda)$"), 
B1=c("$\\sigma^2$","$\\frac{1}{n}$","$1$"),
B2 = c("$\\frac{1}{2}\\mu^2$","$log(1+exp\\beta)$","$exp\\lambda$"),
B3 = c("$-\\frac{1}{2}log(2\\pi\\sigma^2)-\\frac{y^2}{2\\sigma^2}$","$log\\left(\\begin{array}{c}n \\\\ y\\end{array}\\right)$","$-log(y!)$"))

colnames(mathy.df) <- c("Distribución", "$\\beta$", "$a(\\phi)$","$b(\\beta)$","$c(y,\\phi)$")

kable(mathy.df, escape=FALSE)
```
Relación media-varianza:

```{r, echo=FALSE, include=TRUE, results="asis"}
library(knitr)

mathy.df <- data.frame(site = c("Normal","Binomial", "Poisson"), 
                       b0 = c("$\\sigma^2$", "$\\mu(1-\\mu)/n$","$\\mu$"))

colnames(mathy.df) <- c("Distribución", "$v(\\mu)$")

kable(mathy.df, escape=FALSE)
```
#### Estimador de máxima verosimilitud

**Modelo** $Y\sim f(y,\btheta)$.

Estamos interesados en estimar $\btheta$.

Para ello tomamos una muestra independiente $(y_{1},y_{2},...,y_{n}).$

Si las observaciones son independientes, la **función de verosimilitud** es:

$$
L(\btheta)=\prod_{i=1}^nf(y_{i};\btheta).
$$

La función de log-verosimilitud:

$$
 \cl(\btheta)=\sum_{i=1}^nlnf(y_{i},\btheta).
$$

El objetivo es encontrar el $\hat{\btheta}$ que maximiza $L(\btheta)$ (o $\cl(\btheta)$).

$\hat{\btheta}$ se obtiene calculando las derivadas de $\cl(\btheta)$ con respecto a cada elemento de $\btheta$ y resolviendo las **ecuaciones score**:

$$
U(\btheta)=\frac{\partial\cl(\btheta)}{\partial\btheta}=\bZERO.
$$

s necesario verificar si la solución corresponde a un máximo de $\cl(\btheta)$. 
Se requiere que la matriz de segundas derivadas **(matriz Hessiana)**:

$$
H(\btheta)=\frac{\partial^2\cl(\btheta)}{\partial\btheta\partial\btheta^{'}},
$$

evaluada en $\btheta=\hat{\btheta}$, sea negativa definida.

#### Propiedades asintóticas de los MLEs

$\hat{\btheta}$ es asintóticamente $(n\to \infty)$ insesgado. Esto es, $E(\hat{\btheta})=\btheta$.

La varianza asintótica $(n\to \infty)$ de $\hat{\btheta}$ se calcula como la inversa de **la matriz de información**:

$$
v(\hat{\btheta})=I(\btheta)^{-1},\quad \text{donde} \quad I(\btheta)=-E[H(\btheta)]
$$
 **Teorema de Cramer-Rao:** La varianza de cualquier estimador es insesgado de un parámetro $\btheta$ debe:
 
 
 $$
 V(\hat{\btheta})\geq-E[H(\btheta)]^{-1}.
 $$
 
 Por lo cual, es MLE es eficiente.
 
 Otras propiedades importantes:
 
 * **Asintoticamente normal:**$\hat{\btheta}\sim N[\btheta,I(\btheta)^{-1}]$
 
 * **Invarianza:**si $\hat{\btheta}$ es el MLE de $\btheta$, entonces $g(\hat{\btheta})$ es el  MLE de $g(\btheta)$
 
#### Métodos iterativos de maximización

**Algoritmo de Newton-Raphson:**

Considere una expansión de series de Taylor de orden 1 para la función
score, alrededor de $\btheta=\btheta^{(t)}$:

$$
U(\btheta)\approx U(\btheta^{(t)})+H(\btheta^{(t)})+(\btheta-\btheta^{(t)})
$$

Igualando a cero:

$$
 U(\btheta^{(t)})+H(\btheta^{(t)})+(\btheta-\btheta^{(t)})=0
$$
 
Ahora encontramos la solución para $\hat{\btheta^{(t+1)}}$:

$$
\btheta^{(t+1)}=\btheta^{t}-H(\btheta^{t})^{-1}U(\btheta^{t}).
$$

Podemos reemplazar $H(\btheta)$ por $I(\btheta)$ **(algoritmo Fisher's scoring)**.

## GLM 

El modelo lineal generalizado (GLM) asume que:

$$
f(y_{i};\theta_{i},\phi)=exp\{\frac{y_{i}\theta_{i}-b(\theta_{i})}{a(\phi)} +c(y_{i},\phi)\},
$$

donde $\phi>0$. Además, $E(y_{i})=b'(\theta_{i})$ y $V(y_{i})=b''(\theta_{i})a(\phi).$

El **predictor lineal** $\eta_{i}=\bx'_{i}\bbeta$ se relaciona con $\mu_{i}$ a través la **función de enlace:**

$$
\eta_{i}=g(\mu_{i}).
$$

La función de enlace $g(\cdot)$  que transforma $\mu_{i}$ en el parámetro natural $\theta_{i}$ es llamada **función de enlace canónica.**


**Distribución normal:** $\eta_{i}=\mu_{i}$ (identidad), por lo tanto:

$$
\mu_{i}=\eta_{i}
$$

**Distribución Poisson:**$\eta_{i}=log\mu_{i}$ (logarítmica), por lo tanto:

$$
\mu_{i}=exp(\eta_{i})
$$

**Distribución binomial:**$\eta_{i}=log(\frac{\pi_{i}}{1-\pi_{i}})$ (logit), por lo tanto: 

$$
\pi_{i}=\frac{exp(\eta_{i})}{1+exp(\eta_{i})}
$$

### Mortalidad de escarabajos

**Variable respuesta** $y_{i}=\sum_{j=1}^{n_{i}}y_{ij}/n{i}$: proporción de escarabajos muertos.

**Distribución de probabilidad** binomial:

$$
f(n_{i}y_{i};\pi_{i})= \begin{pmatrix} n_{i}\\y_{i} \end{pmatrix}\pi_{i}^{y_{i}}(1-\pi_{i})^{(n_{i}-y_{i})}.
$$

**Función de enlace:**

$$
log(\frac{\pi_{i}}{1-\pi_{i}})=\beta_{0}+\beta_{1}log\text{dosis}_{i}.
$$

### Ataques epilépticos

**Variable respuesta** $y_{i}$: número de ataques epilépticos.

**Distribución de probabilidad** Poisson:

$$
f(y_{i};\lambda_{i})=\frac{\lambda_{i}^{y_{i}}exp(-\lambda_{i})}{y_{i}!}.
$$

**Función de enlace:**

$$
log\lambda_{i}=\beta_{0}+\beta_{1}\text{treat}_{i}+\beta_{2}\text{base}_{i}+\beta_{3}\text{base}_{i}\text{treat}_{i}
$$

### MLE de $\bbeta$

Función de log-verosimilitud:

$$
\cl(\bbeta)=\sum_{i=1}^{n}\cl_{i}(\bbeta)=\sum_{i=1}^{n}logf(y_{i};\theta_{i},\phi)=\sum_{i=1}^{n}\{\frac{y_{i}\theta_{i}-b(\theta_{i})}{a(\phi)}+c(y_{i},\phi)\}
$$

En un GLM tenemos que $\eta_{i}=\bx_{i}'\bbeta=g(\mu_{i})$.

Las funciones score están definidas como:

$$
U(\beta_{j})=\sum_{i=1}^{n}\frac{(y_{i}-\mu_{i})x_{ij}}{V(y_{i})}\frac{\partial\mu_{i}}{\partial\eta_{i}}=0, \quad \text{para} \quad j=0,...,k.
$$

Dado que las funciones score son no-lineales, es necesario estimar $\bbeta$ iterativamente usando el algoritmo de Newton-Raphson.

En forma matricial, tenemos:

Función score:$U(\bbeta)=\bX'\bD\bV^{-1}(\by-\bmu)$,

Función Hessiana: $H(\bbeta)=\bI(\bbeta)=\bX'\bW\bX$

donde:

* $\bV$ es una matriz diagonal con valores $v_{ii}=V(y_{i})$ en la diagonal.

* $\bD$ es una matriz diagonal con valores $d_{ii}=\frac{\partial\mu_{i}}{\partial\eta_{i}}$.

* $\bW$ es una matriz diagonal con  $w_{ii}=\frac{(\partial\mu_{i}/\partial\eta_{i})^2}{V(y_{i})}$.


#### Estimador de máxima verosimilitud

Utilizando el algoritmo de Newton-Raphson (Fisher's scoring):

$$
\bbeta^{(t+1)}=\bbeta^{(t)}+[\bI(\bbeta^{(t)})]^{-1}U(\bbeta^{(t)}).
$$

Equivalentemente, utilizando el **método de mínimos cuadrados iterativamente reponderados:**

$$
\bbeta^{(t+1)}=(\bX'\bW^{(t)}\bX)^{-1}\bX'\bW^{(t)}z^{(t)}
$$

donde, los elementos de $z^{(t)}$ son:

$$
z_{i}^{(t)}=\bx_{i}'\bbeta^{(t)}+(y_{i}-\mu_{i}^{(t)})\frac{\partial\eta_{i}^{(t)}}{\partial \mu_{i}^{(t)}}.
$$

Distribución asintótica del MLE $(n \to \infty)$:

$$
\hat{\bbeta}\sim N[\bbeta,(\bX'\bW\bX)^{-1}],
$$

donde $\bW$ es una matriz diagonal con:

$$
w_{ii}=\frac{(\partial\mu_{i}/\partial\eta_{i})^2}{V(y_{i})}.
$$

Note que los valores de $\bW$ dependen de la función dde elace g $\partial\mu_{i}/\partial\eta_{i}=g'( \mu_{i})$.

#### Mortalidad de escarabajos

Modelo estimado:

$$
\hat{\pi}_{i}=\frac{exp(-60.717+34.27log\text{dosis})}{1+exp(-60.717+34.27log\text{dosis})}
$$
```{r grafescarMedia}
modBin = glm(cbind(dead,n-dead)~logdose,family=binomial)
pred.x = data.frame(logdose = seq(min(logdose),max(logdose),length.out = 50))
pred = predict(modBin,pred.x,type='response')

plot(logdose,dead/n,xlab='log dosis',ylab='proporción de escarabajos muertos',ylim=c(0,1))
lines(pred.x$logdose,pred,col=2,lwd=2)

```

### interpretación de parámetros - modelo logístico

En el caso de la mortalidad de escarabajos, un **odds** está definido como:

$$
\text{odd}(\text{morir}|x)=\frac{P(Y=1|x)}{P(Y=0|x_{i})}=exp(\beta_{0}+x\beta_{1})
$$

Mientras que un **odds ratio** está definido como:

$$
\text{OR}=\frac{\text{odd}(\text{morir}|x=a+1)}{\text{odd}(\text{morir}|x=a)}=\frac{exp(\beta_{0}+(a+1)\beta_{1})}{exp(\beta_0+a\beta_1)}=exp(\beta_1).
$$

Por lo tanto, por cada cambio unitario en $x$ los odds (`chances') de
morir incrementan por un factor de $exp(\beta_1)$.

Por un cambio en$x$ de $a$ a $a+\delta$, $OR=e^{\delta\beta_1}$.

#### Ataques epilépticos

Modelo estimado:

$$
\hat{\lambda}_i=exp(1.245-0.363\text{treat}_i+0.021\text{base}_i+0.0008\text{base}_i\text{treat}_i)
$$

"insertar gráfico de la diapositiva 41"

### Interpretación de parámetros - modelo Poisson

En el modelo Poisson, tenemos que: $E(Y|x)=exp(\beta_0+x\beta_1)$

$$
\beta_1=log[\frac{E(Y|x=a+1)}{E(Y|x=a)}]
$$

Por lo tanto,

$$
exp(\beta_1)=\frac{E(Y|x=a+1)}{E(Y|x=a)}.
$$

Entonces, $exp(\beta_1)$ es una tasa de crecimiento del valor esperado de $Y$ por un incremento de $x$ de una unidad.


#### Algunas consideraciones

Para GLM con función de enlace canónica:

* Matriz hessiana = matriz de información

* Por lo tanto los algoritmos Newton-Raphson y Fisher's scoring
son equivalentes

* La función de log-verosimilitud es concava.

* Por lo tanto, no hay posibilidad de múltiples máximos.

### Pruebas de hipótesis

Al igual que en los modelos lineales, uno puede estar interesado en
realizar pruebas hipótesis sobre los coeficientes del modelo:

$$
\qquad H_0:\bbeta_0=\bZERO \qquad H_1:\bbeta_0 \ne \bZERO
$$

Para esto podemos utilizar:

* Método del score (multiplicadores de Lagrange).

* Método de Wald.

* Método de razón de verosimilitud.

**Modelo completo:**$\boldsymbol\eta=\bX_1\bbeta_1+\bX_2\bbeta_2$.

**Modelo restringido:**$\boldsymbol\eta_0=\bX_1\bbeta_1+\bX_2\bbeta_2^0.$

En este caso, quiero probar:

$$
\qquad H_0:\bbeta_2=\bbeta_2^0 \qquad H_1:\bbeta_2 \ne \bbeta_2^0
$$
donde $\bbeta_2$ es de dimensión $q$ y $\bbeta_2^0$ es de dimensión $p-q$

#### Prueba del score

**Hipótesis:**

$$
\qquad H_0:\beta_2=\beta_2^0 \qquad \beta_2\ne\beta_2^0 
$$

Asintóticamente,$U(\bbeta)\sim N[\bZERO,\bI(\beta)]$, entonces:

$$
U(\bbeta)'\bI(\beta)^{-1}U(\bbeta)\sim \chi^2.
$$

**Estadístico de prueba:**

$$
U_2(\hat{\beta}^0)'\{V[U_2(\hat{\beta}^0)]\}^{-1}U_2(\hat{\beta}^0)\sim \chi^2_{p-q},
$$
donde $\hat{\beta}^0=(\hat{\beta}_1,\beta^0_2)'.$

#### Prueba de wald

**Hipótesis:**

$$
\qquad H_0:\bbeta_2=\bbeta_2^0 \qquad H_1:\bbeta_2 \ne \bbeta_2^0

$$

Asintóticamente, $\hat{\bbeta}\sim N[\bbeta,\bI(\bbeta)^{-1}]$. por lo tanto:

$$
(\hat{\bbeta}-\bbeta)'\bI(\bbeta)(\hat{\bbeta}-\bbeta)\sim\chi^2.
$$

**Estadístico de prueba:**

$$
(\hat{\bbeta}_2-\bbeta_2^0)'[V(\hat{\bbeta}_2)]^{-1}(\hat{\bbeta}_2-\bbeta_2^0)\sim \chi^2_{p-q}.
$$

#### Prueba de razón de verosimilitud

**Hipótesis:**

$$
\quad H_0:\bbeta_2=\bbeta_2^0 \qquad H_1:\bbeta_2\ne\bbeta_2^0
$$

Asintóticamente (y usando aprox. series Taylor de orden 1):

$$
2[\cl(\hat{\bbeta})-\cl(\hat{\bbeta}^0)]\sim\chi^2.
$$

**Estadístico de prueba:**

$$
2[\cl(\hat{\bbeta})-\cl(\hat{\bbeta}^0)]
$$

donde $\hat{\bbeta}^0=(\hat{\bbeta}_1,\bbeta_2^0)'.$

"grafico diapositiva 47"

#### Ejemplo ataques epilépticos

"Tabla"

Prueba de hipótesis:
$$
\qquad H_0:\beta_1=\beta_3=0
$$

"Tabla"


## intervalos de confianza

A partir de los estadísticos de prueba anteriores se pueden encontrar intervalos de confianza para $\hat{\bbeta}$. Por ejemplo usando el estadístico de Wald:

$$
\hat{\beta}\pm z_{\alpha/2}SE(\hat{\beta})
$$

Otra alternativa es a partir de los perfiles de log-verosimilitud, el IC está definido a partir de los valores de $\beta_0$ que satisfacen:

$$
-2[\cl(\beta_0,\hat{\psi}(\beta_0))-\cl(\hat{\bbeta,\hat{\bpsi}})]<\chi^2_1,
$$

donde $\psi$ son los demás parámetros del modelo.

### Intervalo de confianza para la media

Dado que $\hat{\eta_0}=\bx_0'\hat{\bbeta}$ ,por lo tanto (asintóticamente):

$$
\hat{\eta_0}\sim N[\bx_0'\bbeta,\bx_0'\bI(\bbeta)^{-1}\bx_0].
$$

Entonces un intervalo de confianza para $\hat{\eta_0}$ es:

$$
\hat{\eta_0}\pm z_{\alpha/2}\sqrt{\bx_0'I(\bbeta)^{-1}\bx_0}
$$

Para encontrar el intervalo de confianza para $\mu_i$, se hace la transformación $g^{-1}$ a los límites de confianza.

#### Ejemplo mortalidad de escarabajos

```{r grafintervalosescarabajos, include=TRUE}
summary(modBin)

pred.link = predict(modBin,newdata = pred.x,type='link',se.fit = T)

lim.sup = ilogit(pred.link$fit + qnorm(0.975)*pred.link$se.fit)
lim.inf = ilogit(pred.link$fit - qnorm(0.975)*pred.link$se.fit)

plot(logdose,dead/n,xlab='log dosis',ylab='proporción de escarabajos muertos',ylim=c(0,1))
lines(pred.x$logdose,pred)

lines(pred.x$logdose,lim.sup, col=2)
lines(pred.x$logdose,lim.inf, col=2)

```

#### Ataques epilépticos

```{r grafintervalosepilep, include=TRUE}


```
"falta gráfica y tabla"


## Devianza

Considere un GLM con observaciones $\by_i=(y_1,...,y_n)$.

Sea $\cl(\bmu)$ la log-verosimilitud (expresada en función de $\bmu$).

Por lo tanto, $\cl(\bmu)$ es la log-verosimilitud evaluada en el MLE.

La máxima verosimilitud que se puede alcanzar corresponde a $\cl(\by)$ (un modelo con ajuste perfecto $y_i=\mu_i$).

A este modelo, se le conoce como el **modelo saturado.**

La idea es comparar el modelo propuesto contra el modelo saturado:

$$
D=-2[\ell(\hat{\bmu})-\ell(\by)]
$$

Donde:

* $\ell(\by)=\sum_{i=1}^n[y_i\tildetheta_i-b(\tildetheta_i)]/a(\phi)$.

*  $\ell(\hat{\bmu})=\sum_{i=1}^n[y_i\tildetheta_i-b(\tildetheta_i)]/a(\phi)$. "*es y_i o mu_i?"

$\tildetheta_i$ corresponde a la estimación de $\theta_i$ en el modelo saturado $(\tildemu_i=y_i)$

Si el ajuste es pobre, se espera que $D$ sea grande.

**Modelo binomial:**

$$
D=2\sum_{i=1}^n[y_ilog(\frac{y_i}{\hat{\mu}_i})+(n_i-y_i)log(\frac{n_i-y_i}{n_i-\hat{\mu}_i})],
$$

donde $\hat{\mu}_i=n_i\hat{\pi}_i.$

**Modelo Poisson:**

$$
D=2\sum_{i=1}^ny_ilog(\frac{y_i}{\hat{\mu}_i}), \quad \text{donde} \quad \hat{\mu}_i=\hat{\lambda}_i.
$$

**Modelo normal:**

$$
D=2\sum_{i=1}^n(y_i-\hat{\mu}_i)^2.
$$


### El estadístico chi-cuadrado de Pearson

El estadístico chi-cuadrado de Pearson:

$$
X^2=\sum_{i=1}^n\frac{(y_i-\hat{\mu}_i)^2}{v(\hat{\mu}_i)}.
$$

Para el modelo Binomial, tenemos que:

$$
X^2=\sum_{i=1}^n\frac{(y_i-n_i\hat{\pi}_i)^2}{n_i\hat{\pi}_i(1-\hat{\pi})}.
$$

y para el modelo Poisson:

$$
X^2=\sum_{i=1}^n\frac{(y_i-\hat{\mu}_i)^2}{\hat{\mu}_i}.
$$

## Bondad de ajuste

Tanto $D$ como $X^2$ se pueden utilizar para evaluar la bondad del ajuste.

$H_0$ indica que el modelo ajusta bien a los datos, y $H_1$  lo contrario. Por ejemplo, en el caso de un modelo logístico:

$$
H_0:logit(\pi_i)=\beta_0+\sum_{i=1}^k\beta_kx_{ik}
$$

Si $H_0$ es cierta, entonces $D$ y $X_2$ siguen una distribución $\chi_2$ con $(n - p)$ grados de libertadad*.

*La aproximación es buena para datos agrupados.

**Mortalidad de escarabajos**

Los valores de la devianza y el $\chi^2$ de Pearson:

```{r devianzaescarabajos, include=TRUE}
# devianza
D = deviance(modBin)
1-pchisq(D,6) # valor p
# chi-cuadrado de Pearson
X2 = sum(residuals(modBin,type='pearson')^2)
1-pchisq(X2,6) # valor p
```

```{r, echo=FALSE, include=TRUE, results="asis"}
library(knitr)

mathy.df <- data.frame(b4=c("Devianza","$X^2$"), 
                       b0=c(6,6),                    B1=c(11.232,10.026),B2 = c(0.0814,0.1235))

colnames(mathy.df) <- c("", "est","gl","valor-p")

kable(mathy.df, escape=FALSE)
```
## Pseudo $R^2$

El pseudo $R^2$ está definido como:

$$
\qquad \text{pseudo}R^2=\frac{\ell_M-\ell_0}{\ell_S-\ell_0}
$$

donde:

* $\ell_M$: log-versimilitud del modelo ajustado (evaluada en $\hat{\beta}$.

* $\ell_0$: log-versimilitud del modelo nulo (solo con intercepto).

* $\ell_S$: log-versimilitud del modelo saturado.

El pseudo $R^2$ se encuentra entre 0 y 1. Se utiliza para comparar modelos.

## Selección de variables

La selección de variables se puede realizar de la misma forma que en los LMs basándose en indicadores como el AIC y BIC (o alguna modificación de ellos).

**AIC:**

$$
\text{AIC}=-2\ell_M+2p.
$$

**BIC:**

$$
\text{BIC}=-2\ell_M+plog(n).
$$

<!--chapter:end:06-ModeloGeneralizado.Rmd-->

#    Modelo logístico
```{r preamble7, include=FALSE}
library(MASS)
library(knitr)
library(kableExtra)
library(aod)
data(birthwt)
```
## Casos de estudio

### Mortalidad de escarabajos

Número de escarabajos muertos después de cinco horas de
exposición a disulfuro de carbono gaseoso $(CS2mgl^{-1})$ en diversas concentraciones


|log.dosis|Escarabajos Total|Escarabajos Muertos|
|:--------|:----------------|:------------------|
|1.6907|59|6 |
|1.7242|60|13|
|1.7552|62|18|
|1.7842|56|28|
|1.8113|63|52|
|1.8369|59|53|
|1.8610|62|61|
|1.8839|60|60|
¿Hay una relación entre la dosis y la mortalidad de escarabajos?

### datos de escarabajos

```{r, include=TRUE}
logdose <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113, 1.8369, 1.8610, 1.8839)
dead <- c(6, 13, 18, 28, 52, 53, 61, 60) # numbers dead
n <- c(59, 60, 62, 56, 63, 59, 62, 60) # binomial sample sizes
Datos=data.frame(logdose,n,dead)

plot(logdose,dead/n,xlab='log dosis',ylab='proporción de muertos',ylim=c(0,1),pch=16)
```

**Variable respuesta $y_i=\sum_{j=1}^{n_i}y_{ij}/n_{i}$:** proporción de escarabajos muertos.

**Distribución de probabilidad:** binomial:

$$
f(n_iy_i;\pi_i)=\begin{pmatrix} n_i \\ n_iy_i \end{pmatrix} \pi_i^{n_iy_i}(1-\pi_i)^{(n_i-n_iy_i)}.
$$

**Función de enlace:**

$$
log \begin{pmatrix} \frac{\pi_i}{1-\pi_i} \end{pmatrix}=\beta_0+\beta_1log\text{dosis}_i.
$$

### Bajo peso al nacer

Se busca identificar factores de riesgo asociados con el nacimiento de niños con bajo peso (< 2:5 kgs). datos: ```data(birthwt,package= 'MASS'```)

**Muestra:**189 madres atendidas en una clínica.

**Variable respuesta:** Bajo peso al nacer (1 si peso <2.5 kgs, 0 si peso$\geq$2.5 kgs).

Posibles covariables:

* ```age```: edad de la madre (años).

* ```lwt```: peso de la madre antes del embarazo (libras).

* ```smoke```: estado de tabaquismo durante el embarazo (0 no, 1 si).

* ```ptl```: historia de parto prematuro (número de casos).

**Variable respuesta $y_i$:** bajo peso al nacer (0: no, 1: si)

**Distribución de probabilidad:** Bernoulli:

$$
f(y_i;\pi_i)=\pi_i^{y_i}(1-\pi_i)^{(1-y_i)}.
$$

**Función de enlace:**

$$
log\begin{pmatrix} \frac{\pi_i}{1-\pi_i} \end{pmatrix}=\beta_0+\beta_1\text{age}_i+\beta_2\text{lwt}_i+\beta_3\text{smoke}_i+\beta_4\text{ptl}_i.
$$

### Estudio de teratología

Se quiere investigar los efectos de agentes químicos en el desarrollo fetal de ratas. datos: ```data(lirat,package = 'VGAM')```.

**Muestra:** 58 ratas hembras con dietas deficientes en hierro.

**Variable respuesta:** proporción de fetos muertos.

Posibles covariables:

* ```grp```: tratamiento (1: placebo, 2-4: diferentes concentraciones de inyecciones de suplementos de hierro)

* ```hb```: nivel de hemoglobina.

```{r, include=TRUE}
data(lirat,package = 'VGAM')
par(mfrow=c(1,2))
#Proporcion de fetos muestos vs tratamiento
plot(lirat$grp,lirat$R/lirat$N,xlab="Tratamiento",ylab="Proporción de fetos muertos")
#Proporcion de fetos muestos vs Hemoglobina
plot(lirat$hb,lirat$R/lirat$N,xlab="Hemoglobina",ylab="Proporción de fetos muertos")
```

**Variable respuesta $y_i=\sum_{j=1}^{n_i}y_{ij}/n_i$:** proporción de fetos muertos por hembra.

**Distribución de probabilidad:**binomial:

$$
f(n_iy_i;\pi_i)=\begin{pmatrix} n_i \\ n_iy_i \end{pmatrix} \pi_i^{n_iy_i}(1-\pi_i)^{(n_i-n_iy_i)}.
$$

**Función de enlace:**

$$
log\begin{pmatrix} \frac{\pi_i}{1-\pi_i} \end{pmatrix}=\beta_0+\beta_1\text{grp}_{i1}+\beta_2\text{grp}_{i2}+\beta_3\text{grp}_{i3}+\beta_4\text{hb}_i.
$$

## Datos agrupados o datos no agrupados

**Datos agrupados:** Hay $n_i$ observaciones que tienen los mismos valores de las covariables $x_i$.

**Datos no agrupados:** Hay $n_i=1$ (o muy pocas) observaciones por cada $x_i$.

Las propiedades asintóticas de las inferencias para los datos no agrupados aplican cuando $n \to \infty$.

Mientras que para datos agrupados, aplican cuando $\sum_{i=1}^nn_i\to\infty$.

### Datos agrupados

Para datos agrupados, $D$ y $X^2$ sirven para evaluar si el ajuste del modelo es bueno o no.

$H_0$ indica que el modelo se ajusta bien a los datos, $H_1$ lo contrario.

Si $H_0$ es cierta (y $\sum_{i=1}^nn_i\to\infty$), entonces $D$ y $X^2$ siguen una distribución $\chi^2$ con $(n-p)$ grados de libertad.

### Datos no agrupados

Las distribuciones límite para $D$ y $X^2$  no aplican para datos no agrupados.

Tampoco para datos agrupados con $n$ grande y con algunos $n_i$ muy pequeños.

Se puede aproximar $D$ y $X^2$ agrupando $(\bx_i,\hat{\by})$ por particiones del espacio de covariables o por particiones de $\hat{\pi}$.

La falta de ajuste se puede hacer comparando el modelo propuesto contra modelos más generales.

## Modelo logístico

Modelo:

$$
n_iy_i\sim\text{binomial}(n_i,\pi_i),\quad \text{donde} \quad \pi_i=g(\bx_i\bbeta).
$$ 

Entonces: $E(y_i|\bx_i)=\pi_i$ y $V(y_i|\bx_i)=\pi_i(1-\pi_i)/n_i$.

Función de enlace logit: $log\begin{pmatrix} \frac{\pi_i}{1-\pi_i} \end{pmatrix}=\bx_i\bbeta$.

Lo que implica que:

$$
\pi_i=g^{-1}(\bx_i,\bbeta)=\frac{exp(\bx_i'\bbeta)}{1+exp(\bx_i'\bbeta)}=\frac{1}{1+exp(-\bx_i'\bbeta)} 
$$

Aunque podemos utilizar otras funciones de enlace.

### Funciones de enlace alternativas

**Probit:**

$$
\Phi(\pi_i)=\bx'_i\bbeta \quad \pi_i=\Phi(\bx'_i\bbeta),
$$

donde $\Phi(\cdot)$ es función acumulativa de la distribución normal estándar.

**Log-log complementaria:**

$$
\pi_i=1-exp[-exp(\bx'_i\bbeta)] \quad log[-log(1-\pi_i)]=\bx'_i\bbeta.
$$

**Log-log:**

$$
\pi_i=exp[-exp(\bx'_i\bbeta)] \quad -log[-log(\pi_i)]=\bx'_i\bbeta.
$$

```{r,echo=FALSE,include=TRUE}

pred.x = data.frame(logdose = seq(min(logdose),max(logdose),length.out = 50))

modEsc.logit = glm(cbind(dead,n-dead)~logdose,family=binomial(logit))
modEsc.probit = glm(cbind(dead,n-dead)~logdose,family=binomial(probit))
modEsc.cloglog = glm(cbind(dead,n-dead)~logdose,family=binomial(cloglog))

pred.logit = predict(modEsc.logit,pred.x,type='response')
pred.probit = predict(modEsc.probit,pred.x,type='response')
pred.cloglog = predict(modEsc.cloglog,pred.x,type='response')

plot(pred.x$logdose,xlim=c(1.69,1.88),ylim=c(0,1),xlab='log dosis',ylab='proporción de escarabajos muertos')
lines(pred.x$logdose,pred.logit)
lines(pred.x$logdose,pred.probit,col=2)
lines(pred.x$logdose,pred.cloglog,col="green")

```
Estimaciones con funciones de enlace: logit(negro), probit(rojo) y cloglog(verde).

```{r, echo=FALSE, include=TRUE, results="asis"}


mathy.df <- data.frame(b4=c("Intercept", "Dosis","log.lik","AIC"), 
                       b0=c("$\\beta_0$","$\\beta_1$","",""), 
B1=c(-60.72,34.27,-18.71,41.43),
B2 = c(5.18,2.91,"",""),
B3 = c(-34.94,19.73,-18.16,40.32),
B4 = c(2.65,1.49,"",""),
B5 = c(-39.57,22.04,-14.82,33.64),
B6 = c(3.24,180,"",""))

colnames(mathy.df)<-c("Effect","Parm","est.","s.e","est.","s.e","est.","s.e")

kable(mathy.df, escape=FALSE,format = "html", booktabs = T) %>%
  kable_styling(bootstrap_options = "striped",
                full_width = F) %>%
  add_header_above(c("","","logit" = 2, "porbit" = 2, "cloglog" = 2))
```

"insertar tabla najo peso al nacer"

## Curva característica operativa del receptor(ROC)

Para evaluar el poder predictivo del modelo se puede construir una
tabla de contingencia:

```{r, echo=FALSE, include=TRUE, results="asis"}

mathy.df <- data.frame(b4=c(0,1), 
                       b0=c("",""),
                       b1=c("",""))

colnames(mathy.df)<-c("y","0","1")

kable(mathy.df, escape=FALSE,format = "html", booktabs = T,caption = "Tabla de clasificación") %>%
  kable_styling(bootstrap_options = "striped",
                full_width = F) %>%add_header_above(c("","Predicción $\\hat{y}$" = 2)) %>% add_footnote(c("El recuento de casillas en estas tablas permite estimar la sensibilidad=$(\\haty=1|y=1)$ y específicamente=$(\\haty=0|y=0)$."))

```

Para datos no agrupados, la predicción $\hat{y}=1$ cuando $\hat{\pi_i}\geq\pi_0$(por ejemplo 0,5).

Para $\pi_0$, se calcula:

* La sensibilidad $P(\hat y=1|y=1)$.

* La especificidad $P(\hat y=0|y=0)$.

Dado que estos valores dependen de $\pi_0$, se pueden calcular para todos los posibles $\pi_0$.

**Ejemplo - Datos de peso al nacer**

Por ejemplo, si $\pi_0$, tenemos:

"tabla"

Sensibilidad: $10/59 = 0,169$ - especificidad: $123/130 = 0,946$.

Ahora, si $\pi_0= 0,3$:

"tabla"

Sensibilidad: $40/59 = 0,678$ - especificidad: $79/130 = 0,607$.

Sensibilidad (linea negra) - especificidad (linea roja)

"grafico"

Gráfico de $P(\hat y=1|y=1)$ vs $P(\hat y=0|y=0)$

"grafico"

El area bajo la curva de la curva ROC (llamado índice de concordancia) es una medida del poder predictivo del modelo.

### Ejemplo mortalidad de escarabajos

Curva ROC para el modelo logístico:

"grafico roc escarabajos"

### Bajo peso al nacer

Curva ROC para el modelo logístico (negro) y probit (rojo): 

"grafico roc Bajo peso al nacer"

modelo logístico: $AUC= 0,6884$
modelo probit: $AUC= 0,6866$.


## Sobredispersión

En un experimento Bernoulli se asume que los $n_i$ ensayos para la observación $i,\quad y_{i1},...y_in_i$ son independientes.

Por lo tanto, tenemos que:

$$
E(y_i)=\pi_i\quad \text{y} \quad V(y_i)=\pi_i(1-\pi_i)\frac{1}{n_i}.
$$

Pero, hay casos donde las observaciones $y_{i1},...y_in_i$ están correlacionadas, es decir $cor(y_{is},y_{it})\ne0$.

Por lo general, se asume que $cor(y_{is},y_{it})=\phi$, para todo $s\ne t$ (exchangeability property). Entonces:

$$
V(y_{it})=\pi_i(1-\pi_i)\quad \text{y} \quad cor(y_{it},y_{is})=\phi\pi_i(1-\pi_i).
$$

En este caso, tenemos que:

$$
V(y_i)=V\begin{pmatrix} \sum_{j=1}^{n_i}\frac{y_{ij}}{n_i}\end{pmatrix}=\frac{1}{n_i^2} \begin{bmatrix} \sum_{j=1}^{n_i}V(y_{it}+2\sum\sum_{s<t}cov(y_{is},y_{it})) \end{bmatrix}=[1+\phi(n_i-1)]\frac{\pi_i(1-\pi_i)}{n_i}.
$$

Si:

* $\phi=0$, $y_i\sim  binomial(n_i,\pi)$.

* $\phi>0$, tenemos sobredispersión.

* $-(n_i-1)^{-1}<\phi<0$tenemos subdispersión (menos
frecuente).

En el caso del modelo binomial, tenemos que:

$$
v(\pi_i)=\pi_i(1-\pi_i)/n_i.
$$

El estadístico de $\chi^2$ de Pearson es:

$$
X^2=\sum_{i=1}^n\frac{(y_i-\hat{\pi}_i)^2}{\pi_i(1-\pi_1)/n_i}
$$

Un indicador de posible inflación de varianza es:

$$
\hat{\phi}=\frac{X^2}{n-p}.
$$

Si no hay problemas de sobredispersión $\hat{\phi}\approx1$.

## Distribución beta-binomial

Modelo: $y|\pi\sim binomial(n,\pi)$

Donde $\pi\sim beta(\alpha_1,\alpha_2)$, esto es:

$$
f(\pi;\alpha_1,\alpha_2)=\frac{\Gamma(\alpha_1+\alpha_2)}{\Gamma(\alpha_1)\Gamma(\alpha_2)}\pi^{\alpha_1-1}(1-\pi)^{\alpha_2-1}
$$

con $\alpha_1>0$ y $\alpha_2>0$.

Asumiendo $\mu=\frac{\alpha_1}{\alpha_1+\alpha_2}$ y $\theta=1/(\alpha_1+\alpha_2)$, tenemos:

$$
E(\pi)=\mu\quad\text{y}\quad V(\pi)=\mu(1-\mu)\frac{\theta}{1+\theta}.
$$

La distribución beta-binomial se obtiene al marginalizar $y$. Esto es:

$$
f(y;n,\mu,\theta)=\int f(y|\pi)f(\pi)d\pi.
$$

La función de densidad de la distribución beta-binomial es:

$$
f(y;n,\mu,\theta)=\begin{pmatrix} n \\ y \end{pmatrix}\frac{\begin{bmatrix} \Pi_{k=0}^{y-1}(\mu+k\theta)\end{bmatrix} \begin{bmatrix} \Pi_{k=0}^{y-1}(1-\mu+k\theta)\end{bmatrix}}{\begin{bmatrix} \Pi_{k=0}^{y-1}(1+k\theta) \end{bmatrix}},
$$

para $y=0,1,...,n.$

Valor esperado y varianza de $y=s/n$:

$$
E(y)=\mu\quad\text{y}\quad V(y)=\begin{bmatrix} 1+(n-1)\frac{\theta}{1+\theta} \end{bmatrix}\mu(1-\mu)\frac{1}{\mu}.
$$

Por lo cual, $\phi=\theta/(1+\theta)$ es la correlación entre ensayos Bernoulli.

Binomial(15,0.3) (negro) - beta-binomial(15,0.3,$\phi$ = 0,1) (rojo) -beta-binomial(15,0.3,$\phi$ = 0,3) (verde)

"Grafico betabinomial"


### Modelo beta-binomial

Modelo:

$$
n_iy_i|\pi_i\sim binomial(n_i,\pi_i)\\
\pi_i\sim beta(\mu_i,\phi),
$$

Por lo cuál:

$$
E(y_i)=\mu_i\quad\text{y}\quad V(y_i)=[1+(n-1)\phi]\mu_i(1-\mu_i)/n_i
$$

La estimación de los parámetros $(\beta,\phi)$ se hace por máxima verosimilitud.

Dado que $\phi>0)$, el modelo beta-binomial no puede modelar datos con subdispersión.

#### Estudio de teratología

```{r,include=TRUE}
data(lirat,package = 'VGAM')
modlirat.binom = glm(cbind(R,N-R)~hb+as.factor(grp),family=binomial,data=lirat)
summary(modlirat.binom)

modlirat.betabinom =betabin(cbind(R,N-R)~as.factor(grp)+hb,data=lirat,random=~1)
modlirat.betabinom

AIC(modlirat.binom)
AIC(modlirat.betabinom)

deviance(modlirat.binom)
deviance(modlirat.betabinom)
```
























<!--chapter:end:07-ModeloLogistico.Rmd-->

#    Modelo para conteos
```{r preamble8, include=FALSE}
library(HSAUR2)
library(MASS)
library(pscl)
library(kableExtra)
data(epilepsy)
data(eba1977,package='ISwR')
data(crabs,package='asbio')

```

## Casos de estudio
### Ataques de epilepsia
Ensayo clínico para evaluar el impacto de progabida sobre las crisis epilépticas (```data(epilepsy)``` de la librería ```HSAUR2```).

Datos:

* ```age```: edad del paciente.
 
* ```base```: número de ataques epilépticos (x 8 semanas) antes delensayo.

* ```treatment```: tratamiento (placebo, progabida).

* ```seizure.rate```(variable respuesta): número de ataques epilépticos (x dos semanas) luego de 8 semanas.

### Datos de cáncer de pulmón

Incidencia de cáncer de pulmón en cuatro ciudades de Dinamarca entre 1968 y 1971 ```(data(eba1977,package='ISwR'))```.

Variable respuesta: número de casos de cáncer de pulmón.

Covariables:

* Ciudad (Fredericia, Horsens, Kolding, Vejle).

* Grupo de edad (40-54, 55-59, 60-64, 65-69, 70-74, >75).

Dado que el número de casos depende del tamaño de la población, se modela la tasa de casos de cáncer de pulmón: $Y_i/t_i$.

$t_i$ es el tamaño de la población por grupo de edad y ciudad **(offset)**.

Fredericia (línea negra), Horsens (línea roja), Kolding (línea verde), Vejle (línea azul).

```{r, include=TRUE}
cancer.data = eba1977[order(eba1977$city),]

# casos por 1000 habitantes
tasa = 1000*cancer.data$cases/cancer.data$pop
plot(1:6,tasa[cancer.data$city=='Fredericia'],type='b',xlab = 'grupo de edad',
     ylim=range(tasa),ylab='casos por 1000 habitantes',xaxt='n',lwd=2)
axis(1,1:6,c('40-54','55-59','60-64','65-69','70-74','>75'))
lines(1:6,tasa[cancer.data$city=='Horsens'],col=2,type='b',lwd=2)
lines(1:6,tasa[cancer.data$city=='Kolding'],col=3,type='b',lwd=2)
lines(1:6,tasa[cancer.data$city=='Vejle'],col=4,type='b',lwd=2)

```
### Número de cangrejos satélites

Los datos ```crabs``` de la librería ```asbio``` son de un estudio de hembras de cangrejos herradura durante el periodo de desove en una isla en el Golfo de México.

**Variable respuesta:**el número de "satélites de cangrejos" herradura hembras ($n = 173$). Las posibles covariables son:

* ```color```: color (1, medio-claro; 2, medio; 3, medio-oscuro; 4,oscuro).

* ```spine```: condición de la espina dorsal (1, ambos bien; 2, uno gastado o roto; 3, ambos gastados o rotos).

* ```width```: ancho del caparazón (cm).

* ```weight```: peso (kg)

```{r, include=TRUE}
par(mfrow=c(1,2))
hist(crabs$satell,breaks = 20,main='',xlab='número de satálites',ylab='frecuencia')
plot(crabs$satell~weight,data=crabs,xlab='peso (kg)',ylab='número de satálites')
```

## Modelo Poisson

La distribución Poisson se utiliza para modelar variables de tipo conteo (número de eventos por intervalo de tiempo o espacio).

Modelo:

$$
y_i\sim Poisson(\lambda_i), \quad i=1,...,n,\quad \text{donde} \quad \lambda_i=exp(\bx'_i\bbeta),
$$

Por lo tanto: $E(y_i|\bx_i)=V(y_i|\bx_i)=\lambda_i$.

El modelo Poisson también se puede usar como aproximación al modelo binomial cuando $n_i$ es grande y $\pi_i$ es pequeño, con $\mu_i=n_i\pi_i$.

Los conteos $y_i$ son proporcionales a un índice $t_i$ (intervalo de tiempo, área de espacio, tamaño de población). Cuando $t_i$ no es fijo, se debe incluir un término llamado **offset**.

El modelo Poisson asume que $E(y_i|\bx_i) = V (y_i|\bx_i)$. En la práctica, es común encontrar que la varianza es mayor que la media que predice la Poisson **(sobredispersión)**.


En otros casos, la frecuencia de ceros puede ser mayor de lo esperado en el modelo ajustado **(exceso de ceros)**.

### Modelo de conteo con offset

El valor esperado de una variable de de conteo ·$y_i$ es proporcional a un índice $t_i$.

Por lo que se puede modelar la tasa $(y_i/t_i)$ con valor esperado $\lambda_i/t_i$.

En este caso, el predictor lineal queda de la forma:

$$
log\begin{pmatrix}\frac{\lambda_i}{t_i}\end{pmatrix}=\bx'_i\bbeta. \\
log\lambda_i=\bx_i'\bbeta+logt_i,
$$

donde $logt_i$ es llamado **offset.**

Por lo tanto, el valor esperado de $y_i$ es:

$$
\lambda_i=t_iexp(x_i\beta).
$$

#### Datos de cáncer de pulmón

Modelo 1:

$$
log(\mu_i/\text{pop}_i)=\beta_0+\beta_1\text{Horsens}_i+\beta_2\text{Kolding}_i+\beta_3\text{Vejle}_i+\beta_4I\text{(55-59)}_i+\beta_5I\text{(60-64)}_i+\beta_6I\text{(65-69)}_i+\beta_7I\text{(70-74)}_i+\beta_8I\text{(>75)}_i
$$
```{r, include=TRUE}
poisson.model = glm(cases ~ city + age+ offset(log(pop)), 
                    family = poisson(link = "log"), data = cancer.data)

summary(poisson.model)
```
Devianza= 23:447 y AIC= 137:84.

Fredericia (línea negra), Horsens (línea roja), Kolding (línea verde), Vejle (línea azul).

```{r, include=TRUE}
### ajuste del modelo
plot(1:6,tasa[cancer.data$city=='Fredericia'],xlab = 'grupo de edad',
     ylim=range(tasa),ylab='casos por 1000 habitantes',xaxt='n')
axis(1,1:6,c('40-54','55-59','60-64','65-69','70-74','>75'))
points(1:6,tasa[cancer.data$city=='Horsens'],col=2)
points(1:6,tasa[cancer.data$city=='Kolding'],col=3)
points(1:6,tasa[cancer.data$city=='Vejle'],col=4)

pred.tasa = 1000*poisson.model$fitted.values/cancer.data$pop
lines(1:6,pred.tasa[cancer.data$city=='Fredericia'],type='l',lwd=2)
lines(1:6,pred.tasa[cancer.data$city=='Horsens'],col=2,type='l',lwd=2)
lines(1:6,pred.tasa[cancer.data$city=='Kolding'],col=3,type='l',lwd=2)
lines(1:6,pred.tasa[cancer.data$city=='Vejle'],col=4,type='l',lwd=2)
```

Modelo 2:

$$
log(\mu_i/\text{pop}_i)=\beta_0+\beta_1\text{Fredericia}_i+\beta_2\text{edad}_i^*+\beta_3\text{edad}_i^{*2},
$$

donde $\text{edad}_i^{*2}$ es el punto medio de los grupos de edad.

```{r,include=TRUE}
cancer.data$t = c(47,57,62,67,72,77)
cancer.data$Fredericia = as.double(cancer.data$city=='Fredericia')

poisson.model2 = glm(cases ~ Fredericia + t + I(t^2)+ offset(log(pop)), 
                     family = poisson(link = "log"), data = cancer.data)
summary(poisson.model2)
```

Prueba de razón de verosimilitud:

```{r,include=TRUE}
anova(poisson.model2,poisson.model,test='LRT')
```

Fredericia (línea negra), otra ciudad (línea roja).

```{r,include=TRUE}
plot(c(47,57,62,67,72,77),tasa[cancer.data$city=='Fredericia'],xlab = 'grupo de edad',
     ylim=range(tasa),ylab='casos por 1000 habitantes')
points(c(47,57,62,67,72,77),tasa[cancer.data$city=='Horsens'],col=2)
points(c(47,57,62,67,72,77),tasa[cancer.data$city=='Kolding'],col=2)
points(c(47,57,62,67,72,77),tasa[cancer.data$city=='Vejle'],col=2)

pred.tasa = 1000*poisson.model2$fitted.values/cancer.data$pop
lines(c(47,57,62,67,72,77),pred.tasa[cancer.data$city=='Fredericia'],type='l',lwd=2)
lines(c(47,57,62,67,72,77),pred.tasa[cancer.data$city=='Horsens'],col=2,type='l',lwd=2)
```

## Distribución binomial negativa

Modelo:$y|\lambda\sim Poisson(\lambda)$,

donde $\lambda\sim gamma(k,\mu).$ Esto es:

$$
f(\lambda;k,\mu)=\frac{(k/\mu)^k}{\Gamma(k)}exp(-k\lambda/\mu)\lambda^{k-1},
$$

Entonces tenemos:

$$
E(\lambda)=\mu\quad\text{y}\quad V(\lambda)=\mu^2/k
$$

La distribución binomial negativa (Poisson-gamma) se obtiene al marginalizar $y$. Esto es:

$$
f(y;\mu,k)=\int f(y|\lambda)f(\lambda)d\lambda.
$$

La función de densidad de la binomial negativa es:

$$
f(y;\mu,k)=\frac{\Gamma(y+k)}{\Gamma(k)\Gamma(y+1)}\begin{pmatrix} \frac{\mu}{\mu+k}\end{pmatrix}^y \begin{pmatrix} \frac{k}{\mu+k} \end{pmatrix}^k
$$

para $y=0,1,...$

Si definimos $\gamma=1/k$, tenemos que:

$$
E(y)=\mu\quad\text{y}\quad V(y)=\mu(1+\gamma\mu),
$$

para $\gamma>0$ (parámetro de sobredispersión).

### Modelo binomial negativo (Poisson-gamma)

Modelo:

$$
y_i|\lambda_i\sim Poisson(\lambda_i)\\
\lambda_i\sim gamma(\mu_i,\gamma),
$$

donde

$$
\lambda_i=exp(\bx'_i\bbeta).
$$

Por lo cuál:

$$
E(y_i)=\mu_i\quad\text{y}\quad V(y_i)=\mu_i(1+\gamma\mu_i)
$$

La estimación de los parámetros $(\bbeta,\gamma)$ se hace por máxima verosimilitud.


Dado que $\gamma>0$, el modelo binomial negativo no puede modelar datos con subdispersión.

Poisson(3) (negro) - Poisson-gamma($3,\gamma=0.5$) (rojo) - Poisson-gamma($3,\gamma=2$) (verde)

"Grafico comparaciones diapositiva 18"

#### Ataques epilépticos

```{r,include=TRUE}
epilepsy4= epilepsy[epilepsy$period==4,]

modPois = glm(seizure.rate~treatment+base,data=epilepsy4,family=poisson)
summary(modPois)

#library(MASS)
modbinNeg = glm.nb(seizure.rate~treatment+base,data=epilepsy4)
summary(modbinNeg)

```

|Modelo           |Devianza|g.l.|AIC   |
|:----------------|:-------|:---|:-----|
|Poisson          |149.68  |56  |343.44|
|Binomial-negativa|70.124  |56  |313.32|

## Modelo Poisson con ceros infiados

El modelo Poisson con ceros infiados (ZIP):

$$
y_i=\begin{cases} 0 \qquad & \text{con probabilidad}\quad 1-\phi_i \\ Poisson(\lambda_i) \quad & \text{con probabilidad}\quad \phi_i\end{cases}
$$

La distribución de probabilidad incondicional es:

$$
P(y_i=0)=(1-\phi_i)+\phi_iexp(-\lambda_i)
$$

$$
P(y_i=j)=\phi_i\frac{exp(-\lambda_i)\lambda_i^j}{j!},\quad \text{para}\quad j=1,2,...
$$

Los parámetros $\phi_i$ y $\lambda_i$ pueden ser modelados a través de covariables:

$$
logit\phi_i=\bx'_{1i}\bbeta_1 \quad\text{y}\quad log\log\lambda_i\bx'_{2i}\bbeta_2
$$

Poisson(3) (negro) - ZI-Poisson($3,\phi=0.9$)(rojo) -
Poisson-gamma($3,\phi=0.7$)(verde)

"grafica diapositiva 21"


El valor esperado y varianza de $y_i$ son:

$$
E(y_i)=\phi_i\lambda_i\quad\text{y}\quad V(y_i)=\phi_i\lambda_i[1+(1-\phi_i)\lambda_i].
$$

Dado que $E(y_i)<V(y_i)$ el modelo ZIP tiene en cuenta algo de sobredispersión.

En presencia de una sobredispersión mayor, el modelo de ceros inflados puede combinarse con una distribución binomial negativa. Esto es:

$$
y_i=\begin{cases}  0 & \text{con probabilidad} \quad1-\phi_i \\  \text{binomial negativa}(\lambda_i,\gamma)& \text{con probabilidad} \quad\phi_i \end{cases}
$$

## Modelo Hurdle

El modelo Hurdle:

$$
P(Y_i=j)=\begin{cases} 1-\pi_i & \text{si}\quad j=0,\\ \pi_i\frac{f(j;\mu_i)}{1-f(0;\mu_i)} &\text{si}\quad j=1,2,... \end{cases}
$$

La función $f(\cdot;\mu_i)$ puede ser una Poisson o binomial negativa.

$\pi_i$ se puede modelar usando un modelo logístico y un modelo log-lineal para $\mu_i$:

$$
logit\phi_i=\bx'_{1i}\bbeta_1\quad\text{y}\quad log\lambda_i=\bx'_{2i}\bbeta_2.
$$

### Número de cangrejos satélites

```{r,include=TRUE}
# modelo Poisson
Pois.sat = glm(satell~weight,data = crabs,family = poisson)
summary(Pois.sat)
```

```{r,include=TRUE}
# modelo binomial negativo
NB.sat = glm.nb(satell~weight,data=crabs)
summary(NB.sat)
```

```{r,include=TRUE}
#library(pscl)
# modelo de inflación de cero
ZINB.sat1 = zeroinfl(satell~weight | weight,data=crabs,dist='negbin')
summary(ZINB.sat1)
```


```{r,include=TRUE}
# modelo hurdle
HNB.sat = hurdle(satell~weight | weight,data=crabs,dist='negbin')
summary(HNB.sat)
```


```{r, echo=FALSE, include=TRUE, results="asis"}

mathy.df <- data.frame(b0=c("AIC","BIC"), 
                       b1=c(920.1,876.9),
                       b2=c(754.6,764.1),
                       b3=c(715.5,731.3),
                       b4=c(715.3,731.0))

colnames(mathy.df)<-c("","P","NB","ZINB","HNB")

kable(mathy.df, escape=FALSE,format = "html", booktabs = T)%>% kable_styling(bootstrap_options = "striped",
                full_width = F)%>%add_header_above(c("","Modelo" = 4))

```

<!--chapter:end:08-regresionconteos.Rmd-->

# Modelo lineal mixto

```{r preamble9, include=FALSE}

```
## Casos de estudio

### Peso al nacer de corderos

La base de datos (```harville.lamb``` de la librería ```agridat```) contiene información de 62 corderos machos de un solo parto. Estos corderos eran progenie de 23 carneros (machos), por lo que cada cordero tenía
una madre diferente.

Variables

* ```weight```: peso al nacer del cordero en kgs **(respuesta)**.
 
* ```damage```: edad de la madre (1: entre 1-2 años, 2: entre 2-3 años, 3: más de 3 años)

* ```sire```: padre.


"grafica"

### Crecimiento craneofacial de ratas

La base de datos (disponible en el campus virtual) tiene como objetivo evaluar el efecto de la inhibición de la producción de testosterona en el crecimiento craneofacial de ratas Wistar macho. Variables:

* ```response```: longitud de cráneo medida como la distancia en píxeles entre dos puntos bien definidos en las imágenes de rayos X **(respuesta)**.

* ```treat```: tratamiento (control, dosis baja de Decapeptyl y dosis alta de Decapeptyl).

* ```age```: edad de la rata.

Este es un estudio longitudinal, es decir a cada una de las 34 ratas se le tomaron diferentes mediciones en el tiempo.


"grafica"

## Datos correlacionados

En ambos estudios se tienen datos que pueden estar potencialmente correlacionados.

En los datos de los corderos se espera que el peso los corderos recién nacidos del mismo padre estén correlacionados. **Datos en "cluster" o jerárquicos**.

En los datos de las ratas, por lo tanto las observaciones tomadas sobre la misma rata pueden estar correlacionados. **Datos longitudinales**.

## Modelo lineal mixto

Modelo:

$$
y_{ij}=\bx¡_{ij}\bbeta+\bz'_{ij}\bb_i+\epsilon_{ij},
$$

donde:

* $\bx_{ij}$ y $\bx_{ij}$ son vectores de covariables de la $j$-ésima observación y el $i$-ésimo cluster.

* $\bbeta=(\beta_0,\beta_1,...,\beta_{p-1})'$ es el vector de coeficientes de efectos fijos.

* $\bb_i=(b_{0i,},b_{1i},...,b_{q-1,i})'$ el vector de coeficientes aleatorios.

* $\epsilon_{ij}$ es el término del error.

En forma matricial:

$$
\by_i=\bX_i\bbeta+\bZ_i\bb_i+\bepsilon_i,
$$

donde:

* $\by_i=(y_{i1},y_{i2},...,y_{in_1})'$.

* $\bX_i=(\bx_{i1},\bx_{i2},...,\bx_{in_1})'$ es una matriz $n_i\times p$ .

* $\bZ_i=(\bz_{i1},\bz_{i2},...,\bz_{in_1})'$ es una matriz $n_i\times q$.

* $\bbeta=(\beta_{0},\beta_{1},...,\beta_{p-1})'$ es un vector de longitud $p$.

* $\bepsilon_i=(\epsilon_{i1},\epsilon_{i2},...,\epsilon_{in_1})'$.

El LMM asume que:

* $\bepsilon_i\sim N(\bZERO,\sigma^2\bI)$.

* $\bb_i\sim N(\bZERO,\bD$.

* $\bepsilon_i$ y $\bb_i$ son independientes.































<!--chapter:end:09-ModeloEfectosAleatorios.Rmd-->

